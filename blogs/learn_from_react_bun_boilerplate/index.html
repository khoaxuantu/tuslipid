<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="#000000" name="theme-color"><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" crossorigin="anonymous" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC"><link href="/logo/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"><link href="/logo/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/logo/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/logo/site.webmanifest" rel="manifest"><script type="text/javascript">!function(n){if("/"===n.search[1]){var a=n.search.slice(1).split("&").map((function(n){return n.replace(/~and~/g,"&")})).join("?");window.history.replaceState(null,null,n.pathname.slice(0,-1)+a+n.hash)}}(window.location)</script><script defer src="/static/js/main.10678900.js"></script><link href="/static/css/main.d54d4198.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com" rel="preconnect"><link href="https://cdn.jsdelivr.net" rel="preconnect"><link href="https://fonts.googleapis.com" rel="preconnect"><link href="/static/css/925.56646f2c.chunk.css" rel="stylesheet" type="text/css"><title>Tuslipid - What I learned after re-creating a React boilerplate</title><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="author"><meta content="summary_large_image" data-react-helmet="true" name="twitter:card"><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="twitter:creator"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" itemprop="image"><meta content="article" data-react-helmet="true" property="og:type"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" property="og:image"><meta content="Tusss Blogs" data-react-helmet="true" property="og:site_name"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" name="twitter:image"><link href="https://fonts.gstatic.com" rel="preconnect"><link href="https://xuankhoatu.com/blogs/learn_from_react_bun_boilerplate//" rel="canonical" data-react-helmet="true"><meta content="What I learned after re-creating a React boilerplate" data-react-helmet="true" name="title"><meta content="What I learned after re-creating a React boilerplate" data-react-helmet="true" itemprop="name"><meta content="We can learn by re-creating something. This post is
about which things I discovered just by a React boilerplate." data-react-helmet="true" name="description"><meta content="What I learned after re-creating a React boilerplate | Tusss blogs" data-react-helmet="true" property="og:title"><meta content="We can learn by re-creating something. This post is
about which things I discovered just by a React boilerplate." data-react-helmet="true" property="og:description"><meta content="https://xuankhoatu.com/blogs/learn_from_react_bun_boilerplate//" data-react-helmet="true" property="og:url"><meta content="We can learn by re-creating something. This post is
about which things I discovered just by a React boilerplate." data-react-helmet="true" name="twitter:description"><meta content="What I learned after re-creating a React boilerplate | Tusss blogs" data-react-helmet="true" name="twitter:title"><meta content="https://xuankhoatu.com/blogs/learn_from_react_bun_boilerplate//" data-react-helmet="true" name="twitter:url"></head><body><div id="root"><nav class="navbar navbar-wrap"><button aria-label="navbar" class="navbar-trigger" type="button"></button><ul class="navbar-menu navbar-txt menu-animation"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/blogs/">Blogs</a></li><li><a href="/guestbook/">Guestbook</a></li><li><a href="/contact/">Contact</a></li><li><a href="/projects">Projects</a></li></ul></nav><div class="container page-wrapper"><div class="header-grp"><div class="header-txt-blog"><b>What I learned after re-creating a React boilerplate</b></div><div class="body-txt-blog mt-2">Sunday, October 22, 2023</div></div><hr><article class="single-blog-wrapper transition-blog" style="height:auto"><h1 id="introduction">Introduction</h1><blockquote><p>We can learn by re-creating something.</p></blockquote><p>Recently, I love diving deeper into React and already has some works using this library. Yeah, my website is written in React üí©, and another interesting project is written in <a href="https://nextjs.org">NextJS</a>, a React's framework, which is <a href="https://algovisual.xuankhoatu.com/">Algorithms Visualizer</a>.</p><p>They both helped me discovering many meaningful aspects of frontend development, from SPA styling as a beginner to detailed state management, hooks, components, modules, etc.</p><p>Still, I felt like I was missing something very original. It is a kind of thing that we ought to be aware of whenever learning a framework/library, and I only figured it out when <a href="https://bun.sh">Bun</a> was released.</p><blockquote><p>Well, how is the React codebase initialized?</p></blockquote><p>Many people are hyped about Bun, including me. Bun supports <em>jsx</em> and <em>tsx</em> formats with its internal transpiler, so it definitely should be great with React. For this reason, I came up with the idea of starting some small React projects with Bun.</p><p>However, it was not as easy as it seemed. I did not want to use Webpack and Babel if there had already been transpiler support, but the existing templates still kept using them. If we create a React app via Bun template as the following:</p><pre><code class="hljs language-bash">bun create react-app appname
</code></pre><p>We simply use Bun to run <code>npx create-react-app</code> and install all the preset dependencies. That's not what I want. üôÅ</p><p>Thus, the first thing I have to do here is create my own custom boilerplate. Then one day, I found the appropriate templates in the <code>create-templates</code> repository of the Bun community (you can check them out via this <a href="https://github.com/bun-community/create-templates">link</a>).</p><blockquote><p>So, why not try re-creating and customizing it?</p></blockquote><p>After making my own customized boilerplate, I was surprised by discovering many new aspects of a React project. Below, I will share what I have learned so far.</p><h1 id="table-of-contents">Table of Contents</h1><ul><li><a href="#how-are-the-static-contents-served-in-a-web">How are static contents served in a web</a></li><li><a href="#how-the-server-side-rendering-delivers-react-components">How the server-side rendering delivers React components</a></li><li><a href="#at-the-client-side">At the client-side</a></li><li><a href="#inside-the-filesystemrouter-refers-to-nextjss-routing">Inside the FileSystemRouter, refers to NextJS's routing</a></li><li><a href="#custom-the-consolelog">Custom the console.log</a></li></ul><h1 id="how-are-the-static-contents-served-in-a-web">How are the static contents served in a web</h1><p>The basics come first, or more precisely said, everything is constructed upon the basics. Sometimes, we are just too focused on fancy stuff that we forget why there are the things called fundamentals. This time, it hits me hard.</p><p>I found the following code in the <a href="https://github.com/bun-community/create-templates/blob/main/react-ssr/dev.tsx"><code>react-ssr</code></a> template:</p><pre><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">serveFromDir</span>(<span class="hljs-params">config: {
  directory: <span class="hljs-built_in">string</span>;
  path: <span class="hljs-built_in">string</span>;
}</span>): <span class="hljs-title class_">Response</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">let</span> basePath = path.<span class="hljs-title function_">join</span>(config.<span class="hljs-property">directory</span>, config.<span class="hljs-property">path</span>);
  <span class="hljs-keyword">const</span> suffixes = [<span class="hljs-string">''</span>, <span class="hljs-string">'.html'</span>, <span class="hljs-string">'index.html'</span>];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> suffix <span class="hljs-keyword">of</span> suffixes) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> pathWithSuffix = path.<span class="hljs-title function_">join</span>(basePath, suffix);
      <span class="hljs-keyword">const</span> stat = <span class="hljs-title function_">statSync</span>(pathWithSuffix);
      <span class="hljs-keyword">if</span> (stat && stat.<span class="hljs-title function_">isFile</span>()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-title class_">Bun</span>.<span class="hljs-title function_">file</span>(pathWithSuffix));
      }
    } <span class="hljs-keyword">catch</span> (err) {}
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request</span>) {
    ...
    <span class="hljs-keyword">let</span> reqPath = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>).<span class="hljs-property">pathname</span>;
    ...
    <span class="hljs-comment">// check public</span>
    <span class="hljs-keyword">const</span> publicResponse = <span class="hljs-title function_">serveFromDir</span>({
      <span class="hljs-attr">directory</span>: <span class="hljs-variable constant_">PUBLIC_DIR</span>,
      <span class="hljs-attr">path</span>: reqPath,
    });
    <span class="hljs-keyword">if</span> (publicResponse) <span class="hljs-keyword">return</span> publicResponse;
    ...
  }
} satisfies <span class="hljs-title class_">ServeOptions</span>;
</code></pre><p>Like a habit, my head came up with the <code>WTF</code>, that thing was frightening me. Although it looks familiar, somehow I could not understand it at first.</p><blockquote><p>So... I must put myself through what frightening me huh...</p></blockquote><p>It took a long time for me just to regain calm and read the code line by line, and finally, I could break the code into the following pseudocode:</p><pre><code>Define function serveFromDir(directory, filepath):
	basepath -> join directory and file path together
	suffixes -> ['', '.html', 'index.html'] as list

	For each suffix in the suffixes list:
		Try do:
			pathWithSuffix -> join basePath and suffix together
			stat -> get pathWithSuffix's statistic

			If stat exists and stat is a file:
				Return a Response with the blob object of the file located in pathWithSuffix
			End if
		Catch any error
		End try
	End for

	Return null
End define

In Bun serve option
	In async fetch():
		reqPath -> URL's pathname of request.url

		publicResponse -> serveFromDir(PUBLIC_DIR, reqPath)
		If publicResponse exists (not null):
			Return publicResponse as Response
		end if
	end fetch()
end Bun serve otion
</code></pre><p>Typically, the <code>serveFromDir()</code> method resolves the directory and filepath, then checks the statistic in the resolved path. If it knows the statistic exists and there is a file as the resolved path, it will return a <code>Response</code> object containing the file.</p><p>In the Bun serve option, we use the <code>serveFromDir()</code> to map the request pathname to the specific public folder. Thus, if we request to get public content, for example, at <code>http://localhost:3000/image.jpg</code>, the flow will go like this:</p><ol><li>The <code>reqPath</code> is assigned to <code>/image.jpg</code></li><li>Assume we set the <code>PUBLIC_DIR</code> to <code>__dirname + /public</code></li><li>In the <code>serveFromDir()</code>, we will have the <code>basePath</code> which is equivalent to <code>__dirname + /public/image.jpg</code>.</li><li>In the suffix <code>''</code>, we set the <code>pathWithSuffix</code> to the same with <code>basePath</code>, so the code will check the <code>image.jpg</code> in the <code>public</code> folder.</li><li>Assuming there is an <code>image.jpg</code> file in the <code>public</code> folder, it will return a <code>Response</code> object containing the blob object of that file.</li><li>Finally, this <code>Response</code> object is sent to the client browser.</li></ol><p>Recall when we wrote our <code>index.html</code> for the first time, It turns out that everything follows the same concept:</p><ol><li>We request to the server for the content.</li><li>The server resolves the request path, then checks the file system.</li><li>The server returns status <code>200</code> if it finds out the content, or status <code>404</code> if the content is not found.</li></ol><p>We can try to start a http server via the popular <a href="https://www.npmjs.com/package/http-server">http-server</a> command in any static content folder, we will get the whole file system displayed on the browser.</p><p>The difference here is just in the Bun serve option, we have specified a specific directory for the app to look into, not only a root directory.</p><blockquote><p>That's why I found the code so familiar huh...</p></blockquote><h1 id="how-the-server-side-rendering-delivers-react-components">How the server-side rendering delivers React components</h1><p>Originally, React was designed to render components as client-side rendering. Nevertheless, as the web requirements in performance, SEO supports, scaling, etc... were increasing, React must have released the supports on the server-side.</p><p>Since then, many frameworks have been built on top of the React server APIs, for instance, NextJS, Remix, and Gatsby. Again, another question comes along with this concept:</p><blockquote><p>Which APIs do those frameworks use for server-side rendering?</p></blockquote><p>We can easily look it up in React server APIs' <a href="https://react.dev/reference/react-dom/server">documents</a>:</p><ul><li>For Node.js Streams</li></ul><pre><code class="hljs language-ts"><span class="hljs-title function_">renderToPipeableStream</span>()
<span class="hljs-title function_">renderToStaticNodeStream</span>()
</code></pre><ul><li>For Web Streams</li></ul><pre><code class="hljs language-ts"><span class="hljs-title function_">renderToReadableStream</span>()
</code></pre><ul><li>For non-streaming environments</li></ul><pre><code class="hljs language-ts"><span class="hljs-title function_">renderToString</span>()
<span class="hljs-title function_">renderToStaticMarkup</span>()
</code></pre><p>With them, we can generate React components to virtual DOM directly on the server and then send it to the client.</p><p>In a JavaScript server runtime such as Node or my customized boilerplate, Bun, we can call those APIs to perform the React server-side rendering conveniently. With Node, we may use <code>renderToPipeableStream</code> or <code>renderToStaticNodeStream</code> to create a streaming connection that delivers React components. In Bun, we can use <code>renderToReadableStream</code> for the same functionality.</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.tsx"</span>;

<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderToReadableStream</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /></span></span>);
</code></pre><h1 id="at-the-client-side">At the client-side</h1><p>We got the deliveries from the server as above. Now we need to have something to catch the components at the client. React's <code>createRoot()</code> is not a good choice because it will destroy and re-create the DOM nodes whenever there is a new component delivered from the server.</p><p>That is why <code>hydrateRoot()</code> appears.</p><blockquote><p>Call <code>hydrateRoot</code> to "attach" React to existing HTML that was already rendered by React in a server environment.</p><p>---> <a href="https://react.dev/reference/react-dom/client/hydrateRoot">Learn more about React's hydrateRoot</a></p></blockquote><p>For the server-side routing, we may hydrate the entire document:</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom/client"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.tsx"</span>;

<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>, <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /></span></span>);
</code></pre><h1 id="inside-the-filesystemrouter-refers-to-nextjss-routing">Inside the FileSystemRouter, refers to NextJS's routing</h1><p>Bun provides an API for resolving routes against file-system paths with NextJS-style file-system routing called <code>FileSystemRouter</code>.</p><p>I have done some debugging to find out how the routing resolver works, and the result has blown my mind.</p><p>Assume we are running a React app at <code>localhost:3000</code> and have a file system for routing as follows:</p><pre><code>pages/
|--- app.tsx

index.tsx
</code></pre><p>In the file <code>index.tsx</code>, we call <code>FileSystemRouter</code> with the direction assigned to the <code>pages</code> folder.</p><pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> pageRouter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bun</span>.<span class="hljs-title class_">FileSystemRouter</span>({
  <span class="hljs-attr">dir</span>: <span class="hljs-string">'./pages'</span>,
  <span class="hljs-attr">style</span>: <span class="hljs-string">'nextjs'</span>,
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"üöÄ ~ pageRouter:"</span>, pageRouter)
</code></pre><p>By logging the <code>pageRouter</code>, we get the following output at the console:</p><pre><code class="hljs language-bash">üöÄ ~ pageRouter: FileSystemRouter {
  match: [Function: match],
  origin: null,
  reload: [Function: reload],
  routes: {
    <span class="hljs-string">"/app"</span>: <span class="hljs-string">"/home/user/your-work-directory/pages/app.tsx"</span>,
  },
  style: <span class="hljs-string">"nextjs"</span>,
}
</code></pre><p>We can see the <code>FileSystemRouter</code> object has mapped the path to the file system in the <code>routes</code> attribute.</p><p>Then, when we call <code>FileSystemRouter.match</code> method (i.e, request to <code>localhost:3000/app</code>):</p><pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> match = pageRouter.<span class="hljs-title function_">match</span>(request);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match);
</code></pre><pre><code class="hljs language-bash">MatchedRoute {
  filePath: <span class="hljs-string">"/home/user/your-work-directory/pages/app.tsx"</span>,
  kind: <span class="hljs-string">"exact"</span>,
  name: <span class="hljs-string">"/app"</span>,
  params: {},
  pathname: <span class="hljs-string">"/app"</span>,
  query: {},
  scriptSrc: <span class="hljs-string">"app.tsx"</span>,
  src: <span class="hljs-string">"app.tsx"</span>,
}
</code></pre><p>The <code>FileSystemRouter</code> object has resolved the HTTP request and returned a <code>MatchedRoute</code> object, which maps the request path to the file path corresponding to the <code>routes</code> attribute of the <code>FileSystemRouter</code> object. Since then, by receiving the request, the app will have the information to access the corresponding path.</p><p>Therefore, if we build our React app source code (transpile <em>jsx/tsx</em> files to <em>js</em> files) in a build directory called <code>build/</code>, we can use <code>FileSystemRouter</code> to map the request path to the <em>js</em> file path, then send the file to the client so that the client can perform any feature of a React app.</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROJECT_ROOT</span> = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dir</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BUILD_DIR</span> = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">PROJECT_ROOT</span>, <span class="hljs-string">"build"</span>);

<span class="hljs-keyword">const</span> buildMatch = buildRouter.<span class="hljs-title function_">match</span>(req);
</code></pre><h1 id="custom-the-consolelog">Custom the console.log</h1><p>This thing is not related to React, but it is an interesting thing that I found out when re-creating the boilerplate.</p><p>When you run <code>npm start</code> in a <code>create-react-app</code> project, you will get the below console log:</p><p><img alt="Create react app hello console log" src="/images/blogs/react_bun_boilerplate/1.webp" title="create-react-app hello console log"></p><blockquote><p>How to have that colorful console log?</p></blockquote><p>If we want to custom the color, we just simply need to use <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Description">control character</a> to color our output:</p><pre><code class="hljs language-ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\x1b[33m Welcome to the app! \x1b[0m'</span>);
</code></pre><p>If we want to add prefix to console log, we need to override the <code>console.log</code> with JavaScript's <code>bind</code>:</p><pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">"My prefix: "</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">console</span>, prefix);
</code></pre><p>Here is the starting console log in my customized boilerplate:</p><pre><code class="hljs language-ts"><span class="hljs-comment">/**
 * Add prefix to console log
 */</span>
<span class="hljs-keyword">const</span> prefix = <span class="hljs-string">'\x1b[96m['</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>() + <span class="hljs-string">']\x1b[0m -'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">console</span>, prefix );

<span class="hljs-comment">/**
 * A welcome log. It will display whenever the project starts
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hiConsole</span>(<span class="hljs-params">port: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[92mCompiled successfully!\x1b[0m"</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`

Now you can view the project in your browser:

  Local       :   \x1b[96mhttp://localhost:<span class="hljs-subst">${port}</span>\x1b[0m
  IP Address  :   \x1b[96mhttp://127.0.0.1:<span class="hljs-subst">${port}</span>\x1b[0m

üöÄüöÄüöÄ Have fun ~

  `</span>);
}

<span class="hljs-title function_">hiConsole</span>(<span class="hljs-number">3000</span>);
</code></pre><p><img alt="My custom console log" src="/images/blogs/react_bun_boilerplate/2.webp" title="My custom console log"></p><h1 id="conclusion">Conclusion</h1><p>Just by re-creating a simple boilerplate, I can enrich my understanding of React and working with JavaScript environments generally. It also provided insights into the fundamental concept of frontend development, which I must have missed at some points. All in all, it emphasized the importance of going beyond the surface and gaining a deeper comprehension of the tools and processes involved.</p><p>If you want to have a look into my customized React boilerplate with Bun, then you can go to my Github repository <a href="https://github.com/khoaxuantu/Custom-bun-react-app">here</a>.</p><p>Although it only limits React server-side rendering, it is enough to build a small project, such as my <a href="https://meme.xuankhoatu.com/">Meme collection</a>. üòÜ</p><h1 id="references">References</h1><ul><li><a href="https://react.dev">React documentations</a></li><li><a href="https://bun.sh/docs">Bun documentations</a></li><li><a href="https://blog.logrocket.com/using-console-colors-node-js/">Using console colors with Node.js</a></li></ul></article><div class="page-copyright mt-5 pt-5 pb-3"><div><a href="https://github.com/khoaxuantu/tuslipid" rel="noreferrer" target="_blank" aria-label="web source code"><svg color="black" fill="currentColor" height="1em" opacity="0.8" stroke="currentColor" stroke-width="0" style="color:#000" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a></div>Built and designed by Xuan Khoa Tu Nguyen with <a href="https://react.dev/" rel="noreferrer" target="_blank">React</a>, <a href="https://www.typescriptlang.org/" rel="noreferrer" target="_blank">TypeScript</a> and <a href="https://sass-lang.com/" rel="noreferrer" target="_blank">Sass</a>.<br>Copyright ¬© 2023-2024 All Rights Reserved.</div></div></div></body></html>