<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="#000000" name="theme-color"><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" crossorigin="anonymous" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC"><link href="/logo/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"><link href="/logo/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/logo/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/logo/site.webmanifest" rel="manifest"><script type="text/javascript">!function(n){if("/"===n.search[1]){var a=n.search.slice(1).split("&").map((function(n){return n.replace(/~and~/g,"&")})).join("?");window.history.replaceState(null,null,n.pathname.slice(0,-1)+a+n.hash)}}(window.location)</script><link href="https://cdnjs.cloudflare.com" rel="preconnect"><link href="https://cdn.jsdelivr.net" rel="preconnect"><script defer src="/static/js/main.95023875.js"></script><link href="/static/css/main.d54d4198.css" rel="stylesheet"><link href="https://fonts.googleapis.com" rel="preconnect"><link href="/static/css/925.56646f2c.chunk.css" rel="stylesheet" type="text/css"><title>Tuslipid - Uncommon JavaScript Notes - Browser: Document, Events, Interfaces</title><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="author"><meta content="summary_large_image" data-react-helmet="true" name="twitter:card"><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="twitter:creator"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" itemprop="image"><meta content="article" data-react-helmet="true" property="og:type"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" property="og:image"><meta content="Tusss Blogs" data-react-helmet="true" property="og:site_name"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" name="twitter:image"><link href="https://fonts.gstatic.com" rel="preconnect"><link href="https://xuankhoatu.com/blogs/uncommon_javascript_notes_1//" rel="canonical" data-react-helmet="true"><meta content="Uncommon JavaScript Notes - Browser: Document, Events, Interfaces" data-react-helmet="true" name="title"><meta content="Uncommon JavaScript Notes - Browser: Document, Events, Interfaces" data-react-helmet="true" itemprop="name"><meta content="One thing that make JavaScript weird to learn is
how it interacts with the browser DOM, how to control the events, the forms,
and how the resource is loaded." data-react-helmet="true" name="description"><meta content="Uncommon JavaScript Notes - Browser: Document, Events, Interfaces | Tusss blogs" data-react-helmet="true" property="og:title"><meta content="One thing that make JavaScript weird to learn is
how it interacts with the browser DOM, how to control the events, the forms,
and how the resource is loaded." data-react-helmet="true" property="og:description"><meta content="https://xuankhoatu.com/blogs/uncommon_javascript_notes_1//" data-react-helmet="true" property="og:url"><meta content="One thing that make JavaScript weird to learn is
how it interacts with the browser DOM, how to control the events, the forms,
and how the resource is loaded." data-react-helmet="true" name="twitter:description"><meta content="Uncommon JavaScript Notes - Browser: Document, Events, Interfaces | Tusss blogs" data-react-helmet="true" name="twitter:title"><meta content="https://xuankhoatu.com/blogs/uncommon_javascript_notes_1//" data-react-helmet="true" name="twitter:url"></head><body><div id="root"><nav class="navbar navbar-wrap"><button aria-label="navbar" class="navbar-trigger" type="button"></button><ul class="navbar-menu navbar-txt menu-animation"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/blogs/">Blogs</a></li><li><a href="/guestbook/">Guestbook</a></li><li><a href="/contact/">Contact</a></li><li><a href="/projects">Projects</a></li></ul></nav><div class="container page-wrapper"><div class="header-grp"><div class="header-txt-blog"><b>Uncommon JavaScript Notes - Browser: Document, Events, Interfaces</b></div><div class="body-txt-blog mt-2">Sunday, September 3, 2023</div></div><hr><article class="single-blog-wrapper transition-blog" style="height:auto"><h1 id="introduction">Introduction</h1><blockquote><p>One thing that make JavaScript weird to learn is how it interacts with the browser DOM: how to control the events, the forms, how the resource is loaded, etc...</p></blockquote><p>Usually, many JavaScript tutorials tend to integrate DOM manipulation with JS, which may confuse learners as a programming language. We are all introduced by the tutorials to many APIs such as <code>getElementById</code>, <code>getQuerySelector</code>, <code>addEventListener</code>, etc...; but barely understand how those APIs work in the browser, why we have them, and so forth. Talking in more abstract terms, we find it difficult to be able to get a detailed insight into the mechanics of the DOM with JavaScript.</p><p>Therefore, below are the notes that help you to cover the essential parts related to browser interaction using JavaScript. It is based on <a href="https://javascript.info/#tab-2">javascript.info's part 2</a> and requires to have a fundamental knowledge of JavaScript. If you are a newbie in JS, let's check out the <a href="https://javascript.info/#tab-1">javascript.info's part 1</a> first before jumping into this section.</p><h1 id="table-of-contents">Table of Contents</h1><details open><summary>Details</summary><ul><li><a href="#document">Document</a><ul><li><a href="#browser-environment-specs">Browser environment, specs</a></li><li><a href="#dom-tree">DOM tree</a></li><li><a href="#walking-the-dom">Walking the DOM</a></li><li><a href="#searching-getelement-queryselector">Searching: getElement*, querySelector*</a></li><li><a href="#node-properties-type-tag-and-contents">Node properties: type, tag and contents</a></li><li><a href="#attributes-and-properties">Attributes and properties</a></li><li><a href="#modifying-the-document">Modifying the document</a></li><li><a href="#styles-and-classes">Styles and classes</a></li><li><a href="#element-sizes-and-scrolling">Element sizes and scrolling</a></li><li><a href="#window-sizes-and-scrolling">Window sizes and scrolling</a></li><li><a href="#coordinates">Coordinates</a></li></ul></li><li><a href="#introduction-to-events">Introduction to Events</a><ul><li><a href="#introduction-to-browser-events">Introduction to browser events</a></li><li><a href="#bubbling-and-capturing">Bubbling and capturing</a></li><li><a href="#event-delegation">Event delegation</a></li></ul></li></ul></details><h1 id="document">Document</h1><blockquote><p>Manipulate a web-page using JavaScript</p></blockquote><br><h2 id="browser-environment-specs">Browser environment, specs</h2><details open><summary>Details</summary><p>The JavaScript language was intially created for web browsers. Since then, it has evolved into a language with many uses and platforms.</p><p>A platform may be a browser, or a web-server or another <em>host</em>. The JavaScript specification calls that a <em>host environment</em>.</p><p>A host environment provides its own objects and functions in addition to the language core. Web browsers give a means to control web pages, Node.js provides server-side features, and so on.</p><p>Here's a tree view of what we have when JavaScript runs in web browser:</p><pre><code>window
    |--- DOM
    |      |--- document
    |
    |--- BOM
    |      |--- navigator
    |      |--- screen
    |      |--- location
    |      |--- frames
    |      |--- history
    |      |--- XMLHttpRequest
    |
    |--- JavaScript
                |--- Object
                |--- Array
                |--- Function
                ...
</code></pre><p>There's a "root" objet called <code>window</code>. It has 2 roles:</p><ol><li>It is a global object for JavaScript code.</li><li>It represents the "browser window" and provides methods to control it.</li></ol><details><summary><b>DOM (Document Object Model)</b></summary>The Document Object Model, or DOM for short, represents all page content as objects that can be modified.<p>The <code>document</code> object is the main "entry point" to the page.</p><pre><code class="hljs language-js"><span class="hljs-comment">// change the background color to red</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">"red"</span>;

<span class="hljs-comment">// change it back after 1 second</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">""</span>, <span class="hljs-number">1000</span>);
</code></pre><blockquote><p>There's also a separate specification, <a href="https://www.w3.org/TR/cssom-1/">CSS Object Model (CSSOM)</a> for CSS rules and stylesheets, that explains how they are represented as objects, and how to read and write them.</p><p>The CSSOM is used together with the DOM when we modify style rules for the document. In practice though, the CSSOM is rarely required, because we rarely need to modify CSS rules from JavaScript, but that's also possible.</p></blockquote></details><br><details><summary><b>BOM (Browser Object Model)</b></summary>The Browser Object Model (BOM) represents additional objects provided by the browser (host environment) for working with everything except the document.<p>For instace:</p><ul><li>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator">navigator</a> object provides background information about the browser and the operating system. The most widely known properties are:<ul><li><code>navigator.userAgent</code> - about the current browser</li><li><code>navigator.platform</code> - about the platform (can help to differentiate between Windows/Linux/Mac etc)</li></ul></li><li>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location">location</a> object allows us to read the current URL and can redirect the browser to a new one.<pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(location.<span class="hljs-property">href</span>); <span class="hljs-comment">// shows the current URL</span>
<span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(<span class="hljs-string">"Go to Tuslipid?"</span>)) {
    location.<span class="hljs-property">href</span> = <span class="hljs-string">"https://xuankhoatu.com"</span>;
}
</code></pre></li></ul></details></details><br><h2 id="dom-tree">DOM tree</h2><details open><summary>Details</summary><p>The backbone of an HTML document is tags.</p><p>According to the DOM, every HTML tag is an object. Nested tags are "children" of the enclosing one. The text inside a tag is an object as well.</p><p>All these objects are accessible using JavaScript, and we can use them to modify the page.</p><pre><code class="hljs language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">'red'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">''</span>, <span class="hljs-number">3000</span>);
</code></pre><h3 id="an-example-of-the-dom">An example of the DOM</h3><pre><code class="hljs language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>></span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>></span>About Tus<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>></span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>></span>
        Something about Tusss...
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span>
</code></pre><p>The DOM represents HTML as a tree structure of tags. Here's how it looks:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>></span>
  |--- <span class="hljs-tag">&lt;<span class="hljs-name">head</span>></span>
  |       |--- text
  |       |--- <span class="hljs-tag">&lt;<span class="hljs-name">title</span>></span>
  |       |         |--- text "About Tus"
  |
  |--- text
  |
  |--- <span class="hljs-tag">&lt;<span class="hljs-name">body</span>></span>
  |      |--- text "Something about Tusss..."
</code></pre><h3 id="autocorrection">Autocorrection</h3><p>If the browser encounters malformed HTML, it automatically corrects it when making the DOM.</p><p>For instance, the top tag is always <code>&lt;html></code>. Even if it doesn't exist in the document, it will exists in the DOM, because the browser will create it. The same goes for <code>&lt;body></code>.</p><p>As an example, if the HTML file is the single word <code>"Hello"</code>, the browser will wrap it into <code>&lt;html></code> and <code>&lt;body></code>, and add the required <code>&lt;head></code>, and the DOM will be:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>></span>
    |--- <span class="hljs-tag">&lt;<span class="hljs-name">head</span>></span>
    |
    |--- <span class="hljs-tag">&lt;<span class="hljs-name">body</span>></span>
    |       |--- text "Hello"
</code></pre><blockquote><p>An interesting "special case" is tables. by DOM specification they must have <code>&lt;tbody></code> tag, but HTML text may omit it. Then the browser creates <code>&lt;tbody></code> in the DOM automatically</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"table"</span>></span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>></span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>></span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>></span>
</code></pre><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>></span>
    |--- <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>></span>
    |         |--- <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>></span>
    |         |      |--- <span class="hljs-tag">&lt;<span class="hljs-name">td</span>></span>
    |         |      |       |--- text "1"
</code></pre></blockquote><h3 id="other-node-types">Other node types</h3><p>There are <a href="https://dom.spec.whatwg.org/#node">12 node types</a>. In practice we usually work 4 of them:</p><ul><li><code>document</code> - the "entry point" into DOM</li><li>element nodes - HTML tags, the tree building blocks</li><li>text nodes - contain text</li><li>comments - sometimes we can put information here, it won't be shown, but JS can read it from the DOM</li></ul></details><br><h2 id="walking-the-dom">Walking the DOM</h2><details open><summary>Details</summary><p>The DOM allows us to do anything with elements and their contents, but first we need to reach the corresponding DOM object. All operations on the DOM start with the <code>document</code> object - the main "entry point".</p><br><p><img alt="DOM nodes" src="/images/blogs/uncommon_javascript_notes_1/1.webp" title="DOM nodes"></p><br><h3 id="on-top-documentelement-and-body">On top: documentElement and body</h3><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>></span> = document.documentElement
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>></span> = document.body
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>></span> = document.head
</code></pre><blockquote><p><code>document.body</code> can be <code>null</code></p></blockquote><h3 id="children-childnodes-firstchild-lastchild">Children: childNodes, firstChild, lastChild</h3><p>There are 2 terms that we'll use from now on:</p><ul><li><strong>Child nodes (or children)</strong> - elements that are direct children. For instance, <code>&lt;head></code> and <code>&lt;body></code> are children of <code>&lt;html></code> element.</li><li><strong>Descendants</strong> - all elements that are nested in the given one, including children, their children, and so on.</li></ul><pre><code class="hljs language-js">childNodes - lists all child nodes, including text nodes
firstChild - gives fast access to the first children
lastChild - gives fast access to the last children
</code></pre><h3 id="dom-collections">DOM collections</h3><p>As we can see, <code>childNodes</code> looks like an array. But actually it's not an array, but rather a <em>collection</em> - a special array - like iterable object.</p><p>There are 2 important consequences:</p><ul><li>We can use <code>for..of</code> to iterate over it:<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">childNodes</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node);
}
</code></pre></li><li>Array methods won't work, because it's not an array:<pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">childNodes</span>.<span class="hljs-property">filter</span>); <span class="hljs-comment">// undefined (there's no filter method)</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">childNodes</span>).<span class="hljs-property">filter</span>) <span class="hljs-comment">// function</span>
</code></pre></li></ul><blockquote><ul><li>DOM collections are read-only.</li><li>DOM collections are live (current state of DOM).</li><li>Don't use <code>for..in</code> to loop over collections.</li></ul></blockquote><h3 id="siblings-and-the-parent">Siblings and the parent</h3><p><em>Siblings</em> are nodes that are children of the same parent. For instance, <code>&lt;head></code> and <code>&lt;body></code> are siblings:</p><ul><li><code>&lt;body></code> is said to be the "next" or "right" sibling of <code>&lt;head></code></li><li><code>&lt;head></code> is said to be the "previous" or "left" sibling of <code>&lt;body></code> The next sibling is in <code>nextSibling</code> property, and the previous one - in <code>previousSibling</code>. The parent is available as <code>parentNode</code>.</li></ul><pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">parentNode</span> === <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-property">nextSibling</span>); <span class="hljs-comment">// HTMLBodyElement</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">previousSibling</span>); <span class="hljs-comment">// HTMLHeadElement</span>
</code></pre><h3 id="element-only-navigation">Element-only navigation</h3><p>Navigation properties listed above refer to all nodes. But for many tasks we don't want text or comment nodes. We want to manipulate element nodes that represents tags and form the structure of the page.</p><p>So let's see more navigation links that only take <em>element nodes</em> into account:</p><br><p><img alt="element nodes" src="/images/blogs/uncommon_javascript_notes_1/2.webp" title="element nodes"></p><br><p>The links are similar to those given above, just with <code>Element</code> word inside:</p><ul><li><code>children</code> - only those children that are element nodes.</li><li><code>firstElementChild</code>, <code>lastElementChild</code> - first and last element children.</li><li><code>previousElementSibling</code>, <code>nextElementSibling</code> - neighbor elements.</li><li><code>parentElement</code> - parent element.</li></ul><h3 id="more-links-tables">More links: tables</h3><p>The <code>&lt;table></code> element supports (in addition to the given above) these properties:</p><ul><li><code>table.rows</code> - the collection of <code>&lt;tr></code> elements of the table.</li><li><code>table.caption/tHead/tFoot</code> - references to elements <code>&lt;caption></code>, <code>&lt;thead></code>, <code>&lt;tfoot></code></li><li><code>table.tBodies</code> - the collection of <code>&lt;tbody></code> elements (can be many according to the standard, but there will alwas be at lest one - even if it is not in the source HTML, the browser will put it in the DOM).</li></ul><p><code>&lt;thead></code>, <code>&lt;tfoot></code>, <code>&lt;tbody></code> elements provide the <code>rows</code> property:</p><ul><li><code>tbody.rows</code> - the collection of <code>&lt;tr></code> inside.</li></ul><p><code>&lt;tr></code>:</p><ul><li><code>tr.cells</code> - the collection of <code>&lt;td></code> and <code>&lt;th></code> cells inside the given <code>&lt;tr></code></li><li><code>tr.sectionRowIndex</code> - the position (index) of the given <code>&lt;tr></code> inside the enclosing <code>&lt;thead>/&lt;tbody>/&lt;tfoot></code>.</li><li><code>tr.rowIndex</code> - the number of the <code>&lt;tr></code> in the table as a whole (including all table rows).</li></ul><p><code>&lt;td></code> and <code>&lt;th></code>:</p><ul><li><code>&lt;td.cellIndex</code> - the number of the cell inside the enclosing <code>&lt;tr></code>.</li></ul></details><br><h2 id="searching-getelement-queryselector">Searching: getElement*, querySelector*</h2><details open><summary>Details</summary><ul><li><code>document.getElementById</code> - If an element has the <code>id</code> attribute, we can get the element no matter where it is.</li><li><code>elem.querySelectorAll(css)</code> - Returns all elements inside <code>elem</code> matching the given CSS selector.</li><li><code>elem.querySelector(css)</code> - Returns the first element for the given CSS selector.</li><li><code>elem.matches(css)</code> - Checks if an <code>elem</code> matches the given CSS-selector. It returns <code>boolean</code>.</li><li><code>elem.closest(css)</code> - Looks for the nearest ancestor that matches the CSS-selector. The <code>elem</code> itself is also included in the search.</li><li><code>elem.getElementsByTagName(tag)</code> - Looks for elements with the given tag an returns the collection of them. The <code>tag</code> parameter can also be a star <code>"*"</code> for "any tags".</li><li><code>elem.getElementsByClassName(className)</code> - Returns elements that have the given CSS class.</li><li><code>document.getElementsByName(name)</code> returns elements with the given <code>name</code> attribute, document-wide. Very rarely used.</li></ul></details><br><h2 id="node-properties-type-tag-and-contents">Node properties: type, tag and contents</h2><details open><summary>Details</summary><h3 id="dom-node-classes">DOM node classes</h3><p>Different DOM nodes may have different properties. For instance, an element node corresponding to tag <code>&lt;a></code> has a link-related properties, and the one corresponding to <code>&lt;input></code> has input-related properties and so on.</p><p>Each DOM node belongs to the corresponding built-in class. The root of the hierarchy is <a href="https://dom.spec.whatwg.org/#eventtarget">EventTarget</a>, that is inherited by <a href="https://dom.spec.whatwg.org/#interface-node">Node</a>, and other DOM nodes inherit from it.</p><br><p><img alt="DOM node classes" src="/images/blogs/uncommon_javascript_notes_1/3.webp" title="DOM node classes"></p><br><blockquote><p>To see the DOM node class name, we can recall that an object ususally has the <code>constructor</code> property. It references the class constructor, and <code>constructor.name</code> is its name:</p><pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// HTMLBodyElement</span>
</code></pre></blockquote><h3 id="the-nodetype-property">The "nodeType" property</h3><p>The <code>nodeType</code> property provides one more, "old-fashioned" way to get the "type" of a DOM node.</p><p>It has a numeric value:</p><ul><li><code>elem.nodeType == 1</code> for element nodes,</li><li><code>elem.nodeType == 3</code> for text nodes,</li><li><code>elem.nodeType == 9</code> for the document object,</li><li>There are few other values in <a href="https://dom.spec.whatwg.org/#node">the specification</a></li></ul><p>In modern scripts, we can use <code>instanceof</code> and other class-based tests to see the node type, but sometimes <code>nodeType</code> may be simpler.</p><h3 id="tag-nodename-and-tagname">Tag: nodeName and tagName</h3><p>Given a DOM node, we can read its tag name from <code>nodeName</code> or <code>tagName</code> properties:</p><pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">nodeName</span>); <span class="hljs-comment">// BODY</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">tagName</span>); <span class="hljs-comment">// BODY</span>
</code></pre><p>Differences between <code>tagName</code> and <code>nodeName</code>:</p><ul><li>the <code>tagName</code> property exists only for <code>Element</code> nodes.</li><li>the <code>nodeName</code> is defined for any <code>Node</code>:<ul><li>For elements it means the same as <code>tagName</code>.</li><li>For other node types (text, comment, etc...) it has a string with the node type.</li></ul></li></ul><h3 id="innerhtml-the-contents">innerHTML: the contents</h3><p>The <a href="https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin">innerHTML</a> property allows to get the HTML inside the element as a string.</p><h3 id="beware-innerhtml--does-a-full-overwrite">Beware: "innerHTML +=" does a full overwrite</h3><p>We can append HTML like this</p><pre><code class="hljs language-js">elem.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">"&lt;div>Hello&lt;img src='smile.gif'/> !&lt;/div>"</span>;
elem.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">"How goes?"</span>;
</code></pre><p>But we should be very careful about doing it, because what's going on is <em>not</em> an addition, but a full overwrite. Technically, these 2 lines do the same:</p><pre><code class="hljs language-js">elem.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">"..."</span>;
elem.<span class="hljs-property">innerHTML</span> = elem.<span class="hljs-property">innerHTML</span> + <span class="hljs-string">"..."</span>
</code></pre><ol><li>The old contents is removed</li><li>The new <code>innerHTML</code> is written instead (a concatenation of the old and the new one).</li></ol><blockquote><p>As the content is "zeroed-out" and rewritten from the scratch, all images and other resources will be reloaded.</p></blockquote><h3 id="outerhtml-full-html-of-the-element">outerHTML: full HTML of the element</h3><p>The <code>outerHTML</code> property contains the full HTML of the element. That's like <code>innerHTML</code> plus the element itself.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"elem"</span>></span>Hello <span class="hljs-tag">&lt;<span class="hljs-name">b</span>></span>World<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-title function_">alert</span>(elem.<span class="hljs-property">outerHTML</span>);
  <span class="hljs-comment">// element id 'elem'</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><blockquote><p>Unlike <code>innerHTML</code>, writing to <code>outerHTML</code> does not change the element. Instead, it replaces it in the DOM</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>></span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>);

  <span class="hljs-comment">// replace div.outerHTML with &lt;p>...&lt;/p></span>
  div.<span class="hljs-property">outerHTML</span> = <span class="hljs-string">'&lt;p>A new element&lt;/p>'</span>;

  <span class="hljs-comment">// The 'div' still the same</span>
  <span class="hljs-title function_">alert</span>(div.<span class="hljs-property">outerHTML</span>); <span class="hljs-comment">// &lt;div>Hello, world!&lt;/div></span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><p>What happened in <code>div.outerHTML=...</code> is:</p><ul><li><code>div</code> was removed from the document.</li><li>Another piece of HTML <code>&lt;p>A new element&lt;/p></code> was inserted in its place.</li><li><code>div</code> still has its old value. The new HTML wasn't saved to any variable.</li></ul></blockquote><h3 id="nodevaluedata-text-node-content">nodeValue/data: text node content</h3><p>The <code>innerHTML</code> property is only valid for element nodes.</p><p>Other node types, such as text nodes, have their counterpart: <code>nodeValue</code> and <code>data</code> properties. These two are almost the same for practical use, there are only minor specification differences.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>></span>
  Hello
  <span class="hljs-comment">&lt;!-- Comment --></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-keyword">let</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">firstChild</span>;
    <span class="hljs-title function_">alert</span>(text.<span class="hljs-property">data</span>); <span class="hljs-comment">// Hello</span>

    <span class="hljs-keyword">let</span> comment = text.<span class="hljs-property">nextSibling</span>;
    <span class="hljs-title function_">alert</span>(comment.<span class="hljs-property">data</span>); <span class="hljs-comment">// Comment</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span>
</code></pre><h3 id="textcontent-pure-text">textContent: pure text</h3><p>The <code>textContent</code> provides access to the <em>text</em> inside the element: only text, minus all <code>&lt;tags></code></p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"news"</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>></span>Headline!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>></span>Martians attack people!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-comment">// Headline! Martians attack people!</span>
  <span class="hljs-title function_">alert</span>(news.<span class="hljs-property">textContent</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><blockquote><p>Writing to <code>textContent</code> is much more useful, because it allows to write text the "safe way"</p></blockquote><h3 id="the-hidden-property">The "hidden" property</h3><p>The "hidden" attribute and the DOM property specifies whether the element is visible or not</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>></span>Both divs below are hidden<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">hidden</span>></span>With the attribute "hidden"<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"elem"</span>></span>JavaScript assigned the property "hidden"<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  elem.<span class="hljs-property">hidden</span> = <span class="hljs-literal">true</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><h3 id="more-properties">More properties</h3><ul><li><code>value</code> - the value for <code>&lt;input></code>, <code>&lt;select></code> and <code>&lt;textarea></code> (<code>HTMLInputElement</code>, <code>HTMLSelectElement</code>...)</li><li><code>href</code> - the "href" for <code>&lt;a href="..."></code> (<code>HTMLAnchorElement</code>)</li><li><code>id</code> - the value of "id" attribute, for all elements (<code>HTMLElment</code>)</li><li>...and much more...</li></ul></details><br><h2 id="attributes-and-properties">Attributes and properties</h2><details open><summary>Details</summary><h3 id="dom-properties">DOM properties</h3><p>There are a lot of built-in DOM properties, but technically no one limits us, and if there aren't enough, we can add our own.</p><pre><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">myData</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Caesar'</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">'Imperator'</span>
};

<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">myData</span>.<span class="hljs-property">title</span>); <span class="hljs-comment">// Imperator</span>

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">sayTagName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagName</span>);
}

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">sayTagName</span>(); <span class="hljs-comment">// BODY (the value of "this" in the method is document.body)</span>
</code></pre><p>We can also modify built-in prototypes like <code>Element.prototype</code> and add new methods to all elements:</p><pre><code class="hljs language-js"><span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>`</span>);
}
<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello, I'm HTML</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello, I'm BODY</span>
</code></pre><h3 id="html-attributes">HTML attributes</h3><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// test</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span>
</code></pre><p>All attributes are accessible by using the following mthods:</p><ul><li><code>elem.hasAttribute(name)</code> - checks for existence</li><li><code>elem.getAttribute(name)</code> - gets the value</li><li><code>elem.setAttribute(name, value)</code> - sets the value</li><li><code>elem.removeAttribute(name)</code> - removes the attribute</li></ul><blockquote><ul><li>Attribute names are case-insensitive</li><li>We can assign anything to an attribute, but it becomes a string</li><li>All attributes are visible in <code>outerHTML</code></li><li>The <code>attributes</code> collection is iterable and has all the attributes of the element (standard and non-standard) as objects with <code>name</code> and <code>value</code> properties</li></ul></blockquote><h3 id="property-attribute-synchronization">Property-attribute synchronization</h3><p>When a standard attribute changes, the corresponding property is auto-updated, and (with some exception) vice versa.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'input'</span>);

  <span class="hljs-comment">// attribute -> property</span>
  input.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'id'</span>, <span class="hljs-string">'id'</span>);
  <span class="hljs-title function_">alert</span>(input.<span class="hljs-property">id</span>); <span class="hljs-comment">// id (updated)</span>

  <span class="hljs-comment">// property -> attribute</span>
  input.<span class="hljs-property">id</span> = <span class="hljs-string">'newId'</span>;
  <span class="hljs-title function_">alert</span>(input.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'id'</span>)); <span class="hljs-comment">// newId (updated)</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><p>But there are exclusions, for instance <code>input.value</code> synchronizes only from attribute -> property, but not back:</p><pre><code class="hljs language-js"><span class="hljs-comment">// attribute => property</span>
input.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'value'</span>, <span class="hljs-string">'text'</span>);
<span class="hljs-title function_">alert</span>(input.<span class="hljs-property">value</span>) <span class="hljs-comment">// text</span>

<span class="hljs-comment">// NOT property => attribute</span>
input.<span class="hljs-property">value</span> = <span class="hljs-string">'newValue'</span>;
<span class="hljs-title function_">alert</span>(input.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'value'</span>)); <span class="hljs-comment">// text (not updated)</span>
</code></pre><h3 id="dom-properties-are-typed">DOM properties are typed</h3><ul><li>DOM properties are not always strings.</li><li>For instace, the <code>input.checked</code> property (for checkboxes) is a boolean</li><li>The <code>style</code> attribute is a string, but the <code>style</code> property is an object</li><li>The <code>href</code> DOM property is always a <em>full</em> URL, even if the attribute contains a relative URL or just a <code>#hash</code><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#hello"</span>></span>link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-comment">// attribute</span>
  <span class="hljs-title function_">alert</span>(a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'href'</span>)); <span class="hljs-comment">// #hello</span>

  <span class="hljs-comment">//property</span>
  <span class="hljs-title function_">alert</span>(a.<span class="hljs-property">href</span>); <span class="hljs-comment">// full URL in the form https://example.com/page#hello</span>
</span></code></pre></li></ul><h3 id="non-standard-attributes-dataset">Non-standard attributes, dataset</h3><p>Sometimes non-standard attributes are used to pass custom data from HTML to JavaScript, or to "mark" HTML-elements for JavaScript</p><pre><code class="hljs language-html"><span class="hljs-comment">&lt;!-- mark the div to show "name" here --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">show-info</span>=<span class="hljs-string">"name"</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
<span class="hljs-comment">&lt;!-- and age here --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">show-info</span>=<span class="hljs-string">"age"</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-comment">// the code finds an element with the mark and shows what's requested</span>
  <span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Peter"</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> div <span class="hljs-keyword">of</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'[show-info]'</span>)) {
    <span class="hljs-comment">// insert the corresponding info into the field</span>
    <span class="hljs-keyword">let</span> field = div.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'show-info'</span>);
    div.<span class="hljs-property">innerHTML</span> = user[field]; <span class="hljs-comment">// first Pete into "name", then 25 into "age"</span>
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><p>Also they can be used to style an element.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>></span><span class="css">
  <span class="hljs-comment">/* style rely on the custom attribute "order-state" */</span>
  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">"new"</span>]</span> {
    <span class="hljs-attribute">color</span>: green;
  }
  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">"pending"</span>]</span> {
    <span class="hljs-attribute">color</span>: blue;
  }
  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">"canceled"</span>]</span> {
    <span class="hljs-attribute">color</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"order"</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">"new"</span>></span>
  A new order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"order"</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">"pending"</span>></span>
  A pending order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"order"</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">"canceled"</span>></span>
  A canceled order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
</code></pre><p>To avoid conflicts in development, there exist <a href="https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes">data-*</a> attributes.</p><blockquote><p>All attributes starting with "data-" are reserved for programmers' use. They are available in the <code>dataset</code> property</p></blockquote><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">data-about</span>=<span class="hljs-string">"Elephants"</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">about</span>); <span class="hljs-comment">// Elephants</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre></details><br><h2 id="modifying-the-document">Modifying the document</h2><details open><summary>Details</summary><h3 id="creating-an-element">Creating an element</h3><p><code>document.createElement(tag)</code></p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
</code></pre><p><code>document.createTextNode(text)</code></p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">'Lmao'</span>);
</code></pre><h3 id="insertion-method">Insertion method</h3><pre><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(div);
</code></pre><ul><li><code>node.append(...nodes or strings)</code>: append nodes or strings <em>at the end</em> of <code>node</code>.</li><li><code>node.prepend(...nodes or strings)</code>: insert nodes or strings <em>at the beginning</em> of <code>node</code>.</li><li><code>node.before(...nodes or strings)</code>: insert nodes or strings <em>before</em> <code>node</code>.</li><li><code>node.after(...nodes or strings)</code>: insert nodes or strings <em>after</em> <code>node</code>.</li><li><code>node.replaceWith(...nodes or strings)</code>: replaces <code>node</code> with the given nodes or strings.</li></ul><h3 id="insertadjacenthtmltextelement">insertAdjacentHTML/Text/Element</h3><p><code>elem.insertAdjacentHTML(where, html)</code></p><p>The first parameter is a code word, specifying where to insert relative to <code>elem</code>. Must be one of the following:</p><ul><li><code>"beforebegin"</code>: insert <code>html</code> immediately before <code>elem</code>.</li><li><code>"afterbegin"</code>: insert <code>html</code> into <code>elem</code>, at the beginning.</li><li><code>"beforeend"</code>: insert <code>html</code> into <code>elem</code>, at the end.</li><li><code>"afterend"</code>: insert <code>html</code> immediately after <code>elem</code>.</li></ul><p>The method has 2 brothers:</p><ul><li><code>elem.insertAdjacentText(where, text)</code>: the same syntax, but a string of text is inserted "as text" instead of HTML.</li><li><code>elem.insertAdjacentElement(where, elem)</code>: the same syntax, but inserts an element.</li></ul><h3 id="node-removal">Node removal</h3><pre><code class="hljs language-js">elem.<span class="hljs-title function_">remove</span>()
</code></pre><blockquote><p>All insertion methods automatically remove the node from the old place</p></blockquote><h3 id="cloning-nodes-clonenode">Cloning nodes: cloneNode</h3><p>The call <code>elem.cloneNode(true)</code> creates a "deep" clone of the element - with all attributes and subelements. If we call <code>elem.cloneNode(false)</code>, then the clone is made without child elements.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> div2 = div.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// clone the existing div</span>
div2.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'b'</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'Bye there!'</span>; <span class="hljs-comment">// change the clone</span>

div.<span class="hljs-title function_">after</span>(div2); <span class="hljs-comment">// show the clone after the existing div</span>
</code></pre><h3 id="documentfragment">DocumentFragment</h3><p><code>DocumentFragment</code> is a special DOM node that servers as a wrapper to pass around lists of nodes. We canappend other nodes to it, but when we insert it somewhere, then its content is inserted instead.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ul"</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getListContent</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> fragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocumentFragment</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) {
      <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>);
      li.<span class="hljs-title function_">append</span>(i);
      fragment.<span class="hljs-title function_">append</span>(li);
    }

    <span class="hljs-keyword">return</span> fragment;
  }

  ul.<span class="hljs-title function_">append</span>(<span class="hljs-title function_">getListContent</span>()); <span class="hljs-comment">// (*)</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><p>At the last line <code>(*)</code> we append <code>DocumentFragment</code>, but it "blends in", so the resulting structure will be:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>></span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>></span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>></span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span>
</code></pre><blockquote><p><code>DocumentFragment</code> is rarely used explicitly. We mention it mainly because there are some concepts on top of it, like <a href="#template-element">template</a> element, that we'll cover much later.</p></blockquote></details><br><h2 id="styles-and-classes">Styles and classes</h2><details open><summary>Details</summary><p>There are generally 2 ways to style an element:</p><ol><li>Create a class in CSS and add it: <code>&lt;div class="..."></code></li><li>Write properties directly into <code>style</code>: <code>&lt;div style="..."></code></li></ol><p>JavaScript can modify both classes and <code>style</code> properties.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> top = <span class="hljs-comment">/* complex calculations */</span>;
<span class="hljs-keyword">let</span> left = <span class="hljs-comment">/* complex calculations */</span>;

elem.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = top;
elem.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = left;
</code></pre><h3 id="classname-and-classlist">className and classList</h3><p>The <code>elem.className</code> corresponds to the <code>"class"</code> attribute</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>= <span class="hljs-string">"main page"</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">className</span>); <span class="hljs-comment">// main page</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span>
</code></pre><p>Methods of <code>classList</code>:</p><pre><code class="hljs language-javascript">elem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">"class"</span>) <span class="hljs-comment">// Adds the class</span>
elem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">"class"</span>) <span class="hljs-comment">// Removes the class</span>
elem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">"class"</span>) <span class="hljs-comment">// Adds the class if it doesn't exist, otherwise reomves it</span>
elem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">"class"</span>) <span class="hljs-comment">// checks for the given class, returns boolean</span>
</code></pre><h3 id="element-style">Element style</h3><p>The property <code>elem.style</code> is an object that corresponds to what's written in the <code>"style"</code> attribute.</p><pre><code>width => elem.style.width

background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
</code></pre><h3 id="resetting-the-style-property">Resetting the style property</h3><p><code>elem.style.removeProperty('style property)</code>: Remove a property of style</p><h3 id="mind-the-units">Mind the units</h3><pre><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">margin</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// doesn't work</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">margin</span> = <span class="hljs-string">'20px'</span>; <span class="hljs-comment">// Add the CSS unit and it works</span>
</code></pre><h3 id="computed-styles-getcomputedstyle">Computed styles: getComputedStyle</h3><blockquote><p>The <code>style</code> property operates only on the value of the <code>"style"</code> attribute, without CSS cascade.</p></blockquote><p>So we can't read anything that comes from CSS classes using <code>elem.style</code></p><p>There is another method for that: <code>getComputedStyle</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-title function_">getComputedStyle</span>(element, [pseudo])
</code></pre><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> computedStyle = <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);
<span class="hljs-title function_">alert</span>(computedStyle.<span class="hljs-property">marginTop</span>);
<span class="hljs-title function_">alert</span>(computedStyle.<span class="hljs-property">color</span>);
</code></pre></details><br><h2 id="element-sizes-and-scrolling">Element sizes and scrolling</h2><details open><summary>Details</summary><h3 id="sample-element">Sample element</h3><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>></span>
  ...Text...
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>></span><span class="css">
  <span class="hljs-selector-id">#example</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">25px</span> solid <span class="hljs-number">#E6E6E6</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">overflow</span>: auto;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>></span>
</code></pre><p><img alt="sample element" src="/images/blogs/uncommon_javascript_notes_1/4.webp" title="Sample element"></p><blockquote><p>Mind the scrollbar. If the scrollbar is <code>16px</code> wide then the content width remains only <code>300 - 16 = 284px</code>.</p></blockquote><h3 id="geometry">Geometry</h3><p>Here's the overall picture with geometry properties:</p><p><img alt="Geometry picture" src="/images/blogs/uncommon_javascript_notes_1/5.webp" title="Geometry picture"></p><ul><li><code>offsetWidth</code>: The outer width = inner CSS-width + paddings + borders</li><li><code>offsetHeight</code>: The outer height = inner CSS-height + paddings + borders</li><li><code>clientLeft</code>: Left border width</li><li><code>clientTop</code>: Top border width</li><li><code>clientWidth</code>: The inner width = inner CSS-width + paddings (exclude scrollbar)</li><li><code>clientHeight</code>: The inner height = inner CSS-height + paddings (exclude scrollbar)</li><li><code>scrollWidth</code>: The full inner width including the scrolled out parts</li><li><code>scrollHeight</code>: The full inner height including the scrolled out parts</li><li><code>scrollTop</code>: <em>How much is scrolled up</em></li><li><code>scrollLeft</code>: <em>How much is scrolled left</em></li></ul><h3 id="dont-take-widthheight-from-css">Don't take width/height from CSS</h3><p>We should use geometry properties instead of <code>getComputedStyle</code>:</p><ol><li>CSS <code>width/height</code> depend on another property: <code>box-sizing</code> that defines "what is" CSS width and height. A change in <code>box-sizing</code> for CSS purpose may break such JavaScript.</li><li>CSS <code>width/height</code> maybe <code>auto</code><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"elem"</span>></span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-title function_">alert</span>(<span class="hljs-title function_">getComputedStyle</span>(elem).<span class="hljs-property">width</span>); <span class="hljs-comment">// auto</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre></li><li>A scrollbar</li></ol></details><br><h2 id="window-sizes-and-scrolling">Window sizes and scrolling</h2><details open><summary>Details</summary><h3 id="widthheight-of-the-window">Width/height of the window</h3><pre><code class="hljs language-javascript">documentElement.<span class="hljs-property">clientHeight</span>;
documentElement.<span class="hljs-property">clientWidth</span>;
</code></pre><blockquote><p>Not <code>window.innerWidth/innerHeight</code></p><pre><code class="hljs language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>); <span class="hljs-comment">// full window width</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>); <span class="hljs-comment">// window width minus the scrollbar</span>
</code></pre></blockquote><h3 id="widthheight-of-the-document">Width/height of the document</h3><p>Theoretically, as the root document element is <code>document.documentElement</code>, and it encloses all the content, we could measure the document's full size as <code>document.documentElement.scrollWidth/scrollHeight</code>.</p><p>But on that element, for the whole page, these properties do not work as intended. In Chrome/Safari/Opera, if there's no scroll, then <code>documentElement.scrollHeight</code> may be even less than <code>documentElement.clientHeight</code> ! Weird, right?</p><p>To reliably obtain the full document height. we should take the maximum of these properties:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollHeight</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollHeight</span>,
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">offsetHeight</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">offsetHeight</span>,
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>
);
</code></pre><h3 id="get-the-current-scroll">Get the current scroll</h3><p>DOM elements have their current scroll state in their <code>scrollLeft/scrollTop</code> properties.</p><p>For document scroll: <code>document.documentElement.scrollLeft/scrollTop</code></p><p>Speical properties: <code>window.pageXOffset/pageYOffset</code></p><blockquote><p>For historical reasons, these properties are the same:</p><ul><li><code>window.pageXOffset</code> is an alias of <code>window.scrollX</code></li><li><code>window.pageYOffset</code> is an alias of <code>window.scrollY</code></li></ul></blockquote><h3 id="scrolling-scrollto-scrollby-scrollintoview">Scrolling: scrollTo, scrollBy, scrollIntoView</h3><ul><li><code>window.scrollBy(x,y)</code> - scrolls the page <em>relative to its current position</em></li><li><code>widnow.scrollTo(pageX, pageY)</code> - scrolls the page to <em>absolute coordinates</em>, so that the top-left corner of the visible part has coordinates <code>(pageX, pageY)</code> ralative to the document's top-left corner. It's like setting <code>scrollLeft/scrollTop</code></li></ul><p><em><strong>scrollIntoView</strong></em><br>The call to <code>elem.scrollIntoView(top)</code> scrolls the page to make <code>elem</code> visible. It has one argument:</p><ul><li>If <code>top=true</code> (default), then the page will be scrolled to make <code>elem</code> appear on the top of the window. The upper edge of the element will be aligned with the window top.</li><li>If <code>top=false</code>, then the page scrolls to make <code>elem</code> appear at the bottom. The bottom edge of the element will be aligned with the window bottom.</li></ul><h3 id="forbid-the-scrolling">Forbid the scrolling</h3><pre><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">overflow</span> = <span class="hljs-string">"hidden"</span>
</code></pre></details><br><h2 id="coordinates">Coordinates</h2><details open><summary>Details</summary><p>Most JavaScript methods deal with one of 2 coordinate systems:</p><ol><li><strong>Relative to the window</strong> - similar to <code>position: fixed</code>, calculated from the window top/left edge.<ul><li>We'll denote these coordinates as <code>clientX/clientY</code>.</li></ul></li><li><strong>Relative to the document</strong> - similar to <code>position: absolute</code> in the document root, calculated from the document top/left edge.<ul><li>We'll denote them <code>pageX/pageY</code>.</li></ul></li></ol><h3 id="element-coordinates-getboundingclientrect">Element coordinates: getBoundingClientRect</h3><pre><code class="hljs language-javascript">elem.<span class="hljs-title function_">getBoundingClientRect</span>()
</code></pre><p>Returns window coordinates for a minimal rectangle that encloses <code>elem</code> as an object of built-in <a href="https://www.w3.org/TR/geometry-1/#domrect">DOMRect</a> class.</p><p>Main <code>DOMRect</code> properties:</p><ul><li><code>x/y</code>: X/Y-coordinates of the rectangle origin relative to window.</li><li><code>width/height</code>: width/height of the rectangle (can be negative).</li></ul><p>Additionally, there are derived properties:</p><ul><li><code>top/bottom</code>: Y-coordinates for the top/bottom rectangle edge.</li><li><code>left/right</code>: X-coordinates for the left/right rectangle edge.</li></ul><p>Output</p><pre><code class="hljs language-ts"><span class="hljs-attr">x</span>: <span class="hljs-number">10</span>
<span class="hljs-attr">y</span>: <span class="hljs-number">314.82812</span>
<span class="hljs-attr">width</span>: <span class="hljs-number">419.796875</span>
<span class="hljs-attr">height</span>: <span class="hljs-number">21</span>
<span class="hljs-attr">top</span>: <span class="hljs-number">314.82812</span>
<span class="hljs-attr">bottom</span>: <span class="hljs-number">335.828125</span>
<span class="hljs-attr">left</span>: <span class="hljs-number">10</span>
<span class="hljs-attr">right</span>: <span class="hljs-number">429.796875</span>
</code></pre><p>As you can see, <code>x/y</code> and <code>width/height</code> fully describe the element. Derived properties can be easily calculated from them:</p><ul><li><code>left = x</code></li><li><code>top = y</code></li><li><code>right = x + width</code></li><li><code>bottom = y + height</code></li></ul><blockquote><ul><li><p>Coordinates may be decimal fractions, e.g. <code>10.5</code>.</p></li><li><p>Coordinates may be negative. For instance, if the page is scrolled so that <code>elem</code> is now above the window.</p></li></ul></blockquote><h3 id="elementfrompointxy">elementFromPoint(x,y)</h3><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> elem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementFromPoint</span>(x, y);
</code></pre><p>Returns the most nested element at window coordinates <code>(x,y)</code>.</p><h3 id="document-coordinates">Document coordinates</h3><p>The 2 coordinates systems are connected by the formula:</p><ul><li><code>pageY</code> = <code>clientY</code> + height of the scrolled-out vertical part of the document.</li><li><code>pageX</code> = <code>clientX</code> + width of the scrolled-out horizontal part of the document.</li></ul><pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCoords</span>(<span class="hljs-params">elem</span>) {
  <span class="hljs-keyword">let</span> box = elem.<span class="hljs-title function_">getBoundingClientRect</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">top</span>: box.<span class="hljs-property">top</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span>,
    <span class="hljs-attr">right</span>: box.<span class="hljs-property">right</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageXOffset</span>,
    <span class="hljs-attr">bottom</span>: box.<span class="hljs-property">bottom</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span>,
    <span class="hljs-attr">left</span>: box.<span class="hljs-property">left</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageXOffset</span>
  };
}
</code></pre></details><h1 id="introduction-to-events">Introduction to Events</h1><blockquote><p>An introduction to browser events, event properties and handling patterns.</p></blockquote><h2 id="introduction-to-browser-events">Introduction to browser events</h2><details open><summary>Details</summary><p>Here's a list of the most useful DOM events:</p><p><strong>Mouse events:</strong></p><ul><li><code>click</code> when the mouse click on an element</li><li><code>contextmenu</code> when the mouse right-clicks on an element</li><li><code>mouseover</code> / <code>mouseout</code> when the mouse cursor comes over / leaves an element</li><li><code>mousedown</code> / <code>mouseup</code> when the mouse button is pressed / released over an element</li><li><code>mousemove</code> when the mouse is moved</li></ul><p><strong>Keyboard events:</strong></p><ul><li><code>keydown</code> and <code>keyup</code> when a keyboard key is pressed and released</li></ul><p><strong>Form element events:</strong></p><ul><li><code>submit</code> when the visitors submits a <code>&lt;form></code></li><li><code>focus</code> when the visitor focuses on an element, e.g. on an <code>&lt;input></code></li></ul><p><strong>Document events:</strong></p><ul><li><code>DOMContentLoaded</code> when the HTML is loaded and processed, DOM is fully built</li></ul><p><strong>CSS events:</strong></p><ul><li><code>transitioned</code> when a CSS-animation finishes</li></ul><h3 id="event-handlers">Event handlers</h3><p>To react on events we can assign a <em>handler</em> - a function that runs in case of an event.</p><h4 id="html-attribute">HTML-attribute</h4><p>A handler can be set in HTML with an attribute named <code>on&lt;event></code>.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Slap me"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('Slapped!')"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>></span>
</code></pre><h4 id="dom-property">DOM property</h4><p>We can assign a handler using a DOM property <code>on&lt;event></code>.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"elem"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Slap me"</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">const</span> elem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'elem'</span>);
  elem.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Ouch...'</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><h3 id="possible-mistakes">Possible mistakes</h3><p>We can set an existing function as a handler. But be careful: the function should be assigned without parentheses</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayThanks</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Thanks!'</span>);
}

elem.<span class="hljs-property">onclick</span> = sayThanks; <span class="hljs-comment">// ok</span>
elem.<span class="hljs-property">onclick</span> = <span class="hljs-title function_">sayThanks</span>(); <span class="hljs-comment">// nope</span>
</code></pre><p>If we add parentheses, then <code>sayThanks()</code> becomes a function call. So the last line actually takes the <em>result</em> of the function execution, that is <code>undefined</code> (as the function returns nothing), and assigns it to <code>onclick</code>. That's doesn't work because we need to assign the function.</p><p>...On the other hand, in the markup we do need the parentheses:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"sayThanks()"</span>></span>
</code></pre><p>When the browser reads the attribute, it creates a handler function with body from the attribute content.</p><blockquote><p>Don't use <code>setAttribute</code> for handlers. Such a call won't work:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// a click on &lt;body> will generate errors,</span>
<span class="hljs-comment">// because attributes are always strings, function becomes a string</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'onclick'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>) });
</code></pre></blockquote><h3 id="addeventlistener">addEventListener</h3><p>The fundamental problem of the aforementioned ways to assign handlers is that we <em>can't assign multiple handlers to one event.</em></p><p>Developers of web standards understood that long ago and suggested an alternative way of managing handlers using the special methods <code>addEventListener</code> and <code>removeEventListener</code> which aren't bound by such constaint.</p><p>The syntax to add a handler:</p><pre><code class="hljs language-javascript">element.<span class="hljs-title function_">addEventListener</span>(event, handler, [options])
</code></pre><p><code>event</code><br>Event name, e.g. <code>"click"</code></p><p><code>handler</code><br>The handler function.</p><p><code>options</code><br>An addition optional object with properties:</p><ul><li><code>once: boolean</code>: if <code>true</code>, then the listener is automatically removed after it triggers.</li><li><code>capture: boolean</code>: the phase where to handle the event.</li><li><code>passive: boolean</code>: if <code>true</code>, then the handler will not call <code>preventDefault()</code></li></ul><p>To remove the handler, use <code>removeEventListener</code>:</p><pre><code class="hljs language-javascript">element.<span class="hljs-title function_">removeEventListener</span>(event, handler)
</code></pre><h3 id="event-object">Event object</h3><p>To properly handle an event we'd want to know more about what's happened. Not just a "click" or a "keydown", but whate were the pointer coordinates? Which key was pressed? And so on.</p><p>When an event happens, the browser creates an <em>event object</em>, puts details into it and passes it as an argument to the handler.</p><pre><code class="hljs language-javascript">elem.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-comment">// show event type, element and coordinates of the click</span>
  <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">type</span> + <span class="hljs-string">" at "</span> + event.<span class="hljs-property">currentTarget</span>);
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Coordinates: "</span> + event.<span class="hljs-property">clientX</span> + <span class="hljs-string">":"</span> + event.<span class="hljs-property">clientY</span>);
}
</code></pre><h3 id="object-handlers-handleevent">Object handlers: handleEvent</h3><p>We can assign not just a function, but an object as an event handler using <code>addEventListener</code>. When an event occurs, its 'handleEvent' method is called.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-title function_">handleEvent</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">type</span> + <span class="hljs-string">" at "</span> + event.<span class="hljs-property">currentTarget</span>);
  }
};

elem.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, obj);
</code></pre></details><h2 id="bubbling-and-capturing">Bubbling and capturing</h2><details open><summary>Details</summary><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('The handler!')"</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">em</span>></span>If you click on <span class="hljs-tag">&lt;<span class="hljs-name">code</span>></span>EM<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>></span>, the handler on <span class="hljs-tag">&lt;<span class="hljs-name">code</span>></span>DIV<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>></span> runs.<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
</code></pre><h3 id="bubbling">Bubbling</h3><blockquote><p>When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.</p></blockquote><pre><code class="hljs language-html"><span class="hljs-comment">&lt;!-- The event handlers will be triggered from p -> div -> form --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"form"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid black; cursor: pointer;"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">"alert"</span>></span>
  --> click on FORM
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid black; margin: 10px; cursor: pointer;"</span>></span>
    --> click on DIV
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"p"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid black; margin: 10px; cursor: pointer;"</span>></span> --> click on P<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>></span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span>
</code></pre><h3 id="eventtarget">event.target</h3><p>A handler on a parent element can always get the details about where it actually happened.</p><blockquote><p>The most deeply nested element that caused the event is called a <em>target</em> element, accessible as <code>event.target</code>.</p></blockquote><p>The differences from <code>this</code> (= <code>event.currentTarget</code>):</p><ul><li><code>event.target</code>: is the "target" element that initiated the event, it doesn't change through the bubbling process.</li><li><code>this</code>: is the "current" element, the one that has a currently running handler on it.</li></ul><h3 id="stopping-bubbling">Stopping bubbling</h3><p>A bubbling event goes from the target element straight up. Normally it goes upwards till <code>&lt;html></code>, and then to <code>document</code> object, and some events even reach <code>window</code>, calling all handlers on the path.</p><p>But any handler may decide that the event has been fully processed and stop the bubbling.</p><p>The method for it is <code>event.stopPropagation()</code>.</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert(`the bubbling doesn't reach here`)"</span>></span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"event.stopPropagation()"</span>></span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span>
</code></pre><h3 id="capturing">Capturing</h3><p>There's another phase of event processing called "capturing". It is rarely used in real code, but sometimes can be useful.</p><p>The standard <a href="https://www.w3.org/TR/DOM-Level-3-Events/">DOM Events</a> describes 3 phases of event propagation:</p><ol><li>Capturing phase - the event goes down to the element.</li><li>Target phase - the event reached the target element.</li><li>Bubbling phase - the event bubbles up from the element.</li></ol><p><img alt="Event propagation" src="/images/blogs/uncommon_javascript_notes_1/6.webp" title="Event propagation visualizer"></p><p>To catch an event on the capturing phase, we need to set the handler <code>capture</code> option to <code>true</code>:</p><pre><code class="hljs language-js">elem.<span class="hljs-title function_">addEventListener</span>(..., {<span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>});

<span class="hljs-comment">// or, just "true" is an alias to {capture: true}</span>
elem.<span class="hljs-title function_">addEventListener</span>(..., <span class="hljs-literal">true</span>);
</code></pre><p>There are 2 possible values of the <code>capture</code> option:</p><ul><li>If <code>false</code> (default), then the handler is set on the bubbling phase.</li><li>If it's <code>true</code>, then the handler is set on the capturing phase.</li></ul></details><br><h2 id="event-delegation">Event delegation</h2><p>Capturing and bubbling allow us to implement one of the most powerful event handling patterns called <em>event delegation</em>.</p><p>The idea is that if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them - we put a single handler on their common ancestor.</p><p>See the detailed example <a href="https://javascript.info/event-delegation">here.</a></p><blockquote><p>Updating...</p></blockquote></article><div class="page-copyright mt-5 pt-5 pb-3"><div><a href="https://github.com/khoaxuantu/tuslipid" rel="noreferrer" target="_blank" aria-label="web source code"><svg color="black" fill="currentColor" height="1em" opacity="0.8" stroke="currentColor" stroke-width="0" style="color:#000" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a></div>Built and designed by Xuan Khoa Tu Nguyen with <a href="https://react.dev/" rel="noreferrer" target="_blank">React</a>, <a href="https://www.typescriptlang.org/" rel="noreferrer" target="_blank">TypeScript</a> and <a href="https://sass-lang.com/" rel="noreferrer" target="_blank">Sass</a>.<br>Copyright © 2023-2024 All Rights Reserved.</div></div></div></body></html>