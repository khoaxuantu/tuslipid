<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="#000000" name="theme-color"><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" crossorigin="anonymous" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC"><link href="/logo/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"><link href="/logo/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/logo/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/logo/site.webmanifest" rel="manifest"><script type="text/javascript">!function(n){if("/"===n.search[1]){var a=n.search.slice(1).split("&").map((function(n){return n.replace(/~and~/g,"&")})).join("?");window.history.replaceState(null,null,n.pathname.slice(0,-1)+a+n.hash)}}(window.location)</script><link href="https://cdnjs.cloudflare.com" rel="preconnect"><link href="https://cdn.jsdelivr.net" rel="preconnect"><script defer src="/static/js/main.6cba0be9.js"></script><link href="/static/css/main.ce584f9e.css" rel="stylesheet"><link href="https://fonts.googleapis.com" rel="preconnect"><link href="/static/css/925.5cc9aec9.chunk.css" rel="stylesheet" type="text/css"><title>Tuslipid - Uncommon JavaScript Notes - The language</title><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="author"><meta content="summary_large_image" data-react-helmet="true" name="twitter:card"><meta content="Xuan Khoa Tu Nguyen" data-react-helmet="true" name="twitter:creator"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" itemprop="image"><meta content="article" data-react-helmet="true" property="og:type"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" property="og:image"><meta content="Tusss Blogs" data-react-helmet="true" property="og:site_name"><meta content="/seo/blogs-tuslipid.webp" data-react-helmet="true" name="twitter:image"><link href="https://fonts.gstatic.com" rel="preconnect"><link href="https://xuankhoatu.com/blogs/uncommon_javascript_notes/" rel="canonical" data-react-helmet="true"><meta content="Uncommon JavaScript Notes - The language" data-react-helmet="true" name="title"><meta content="Uncommon JavaScript Notes - The language" data-react-helmet="true" itemprop="name"><meta content="JavaScript is super complicated, like a pain in your ass.
            Even when you are quite familiar with programming languages logics and concepts,
            you still find it difficult to cover major aspects in JS." data-react-helmet="true" name="description"><meta content="Uncommon JavaScript Notes - The language | Tusss blogs" data-react-helmet="true" property="og:title"><meta content="JavaScript is super complicated, like a pain in your ass.
            Even when you are quite familiar with programming languages logics and concepts,
            you still find it difficult to cover major aspects in JS." data-react-helmet="true" property="og:description"><meta content="https://xuankhoatu.com/blogs/uncommon_javascript_notes/" data-react-helmet="true" property="og:url"><meta content="JavaScript is super complicated, like a pain in your ass.
            Even when you are quite familiar with programming languages logics and concepts,
            you still find it difficult to cover major aspects in JS." data-react-helmet="true" name="twitter:description"><meta content="Uncommon JavaScript Notes - The language | Tusss blogs" data-react-helmet="true" name="twitter:title"><meta content="https://xuankhoatu.com/blogs/uncommon_javascript_notes/" data-react-helmet="true" name="twitter:url"></head><body><div id="root"><nav class="navbar navbar-wrap"><button aria-label="navbar" class="navbar-trigger" type="button"></button><ul class="navbar-menu navbar-txt menu-animation"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/blogs">Blogs</a></li><li><a href="/guestbook">Guestbook</a></li><li><a href="/contact">Contact</a></li><li><a href="/projects">Projects</a></li></ul></nav><div class="container page-wrapper"><div class="header-grp"><div class="header-txt-blog"><b>Uncommon JavaScript Notes - The language</b></div></div><hr><article class="single-blog-wrapper transition-blog" style="height:auto"><h1 id="introduction">Introduction</h1><blockquote><p>JavaScript is super complicated, like a pain in your ass. Even when you are pretty familiar with other programming languages' logic and concepts, you still find it challenging to cover significant aspects of JS.</p></blockquote><p>Let me tell you one story... I once started learning JavaScript with a mindset that "just like other programming languages". Honestly, it does have enough general programming concepts that help me gain some first tastes quickly. It has variables, operators, functions, objects and classes, which can make a newbie think: "Uhm ~~ I can understand it easily!". But the thing doesn't go as you expected, not like variables in C++, variables in JavaScript have <code>var</code>, <code>const</code> and <code>let</code>; not like a single <code>def</code> in Python, JavaScript can initiate a function in two ways: function declaration and function expression. Thus, I didn't understand its fundamentals the first time studying, and regularly lost track of my thinking flow when looking up its advanced topic. Although I have done some projects using extended JavaScript and libraries/frameworks such as React, ExpressJS, etc..., I still had a vague picture about prototypes, asynchronous, error handling, and so forth.</p><p>Things even got worse, I got an invitation to a whiteboard technical interview for a full-stack developer role, in which they asked me about JavaScript. Initially, I believe naively my fundamental ideas can handle their questions - "Well! Just some JS questions like tutorials". However, they gave me a question about asynchronous which is one of my most vulnerable parts. They asked me about a promise chain meanwhile I just had been familiar with a single promise. As a result, I solved it incompletely and failed the interview. 🥲</p><pre><code class="hljs language-js"><span class="hljs-comment">// Refactor the function below to async/await structure</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
        <span class="hljs-title function_">resolve</span>(B);
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resB</span> =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">C</span>(resB);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First error: <span class="hljs-subst">${err}</span>`</span>);
    });
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resC</span> =></span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">D</span>(resC);
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resD</span> =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resD);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Second error: <span class="hljs-subst">${err}</span>`</span>);
    })
}
</code></pre><p>After the interview, I realized my huge gap in knowledge about JavaScript, so I started reviewing it again. Below are my keynotes based on <a href="https://javascript.info/">javascript.info</a>. It does not have very fundamental topics, instead, it contains concepts that I can easily mismatch when learning. So for looking up JavaScript basics, you can refer to <a href="https://javascript.info/">javascript.info tutorials</a> directly or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN (Mozilla) JavaScript manual</a>.</p><p><br><br></p><hr><h2 id="content">Content</h2><details open><ul><li><a href="#javascript-fundamentals">JavaScript Fundamentals (but uncommon)</a><ul><li><a href="#variables">Variables</a></li><li><a href="#data-types">Data types</a></li><li><a href="#interaction">Interaction</a></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#logical-operators">Logical Operators</a></li><li><a href="#nullish-coalescing-operator---">Nullish coalescing operation <code>??</code></a></li><li><a href="#loop-for">Loop <code>for</code></a></li><li><a href="#functions">Functions</a></li></ul></li><li><a href="#code-quality">Code quality</a><ul><li><a href="#polyfills-and-transpilers">Polyfills and transpilers</a></li></ul></li><li><a href="#objects-the-basics">Objects: the basics</a><ul><li><a href="#objects">Objects</a></li><li><a href="#symbol-type">Symbol type</a></li></ul></li><li><a href="#more-about-data-types">More about data types</a><ul><li><a href="#iterables">Iterables</a></li><li><a href="#objectkeys-values-entries">Object.keys, values, entries</a></li><li><a href="#destructuring-assignment">Destructuring assignment</a></li><li><a href="#date-and-time">Date and time</a></li><li><a href="#json-methods-tojson">JSON methods, toJSON</a></li></ul></li><li><a href="#advanced-working-with-functions">Advanced working with functions</a><ul><li><a href="#rest-parameters-and-spread-syntax">Rest parameters and spread syntax</a></li><li><a href="#the-old-var">The old <code>var</code></a></li><li><a href="#global-object">Global object</a></li><li><a href="#the-new-function-syntax">The <code>new Function</code> syntax</a></li><li><a href="#scheduling-settimeout-and-setinterval">Scheduling: <code>setTimeout</code> and <code>setInterval</code></a></li><li><a href="#decorators-and-forwarding-call-apply">Decorators and forwarding, call/apply</a></li><li><a href="#function-binding">Function binding</a></li></ul></li><li><a href="#object-properties-configuration">Object properties configuration</a><ul><li><a href="#property-flags-and-descriptors">Property flags and descriptors</a></li></ul></li><li><a href="#prototypes-inheritance">Prototypes, inheritance</a><ul><li><a href="#prototypal-inheritance">Prototypal inheritance</a></li><li><a href="#f-prototype">F.prototype</a></li><li><a href="#native-prototypes">Native prototypes</a></li></ul></li><li><a href="#classes">Classes</a></li><li><a href="#error-handling">Error handling</a><ul><li><a href="#custom-errors-extending-error">Custom errors, extending Error</a></li></ul></li><li><a href="#promises-asyncawait">Promises, async/await</a><ul><li><a href="#introduction-callbacks">Callbacks</a></li><li><a href="#promise">Promise</a></li><li><a href="#promise-chaining">Promise chaining</a></li><li><a href="#error-handling-with-promises">Error handling with promises</a></li><li><a href="#promise-api">Promise API</a></li><li><a href="#promisification">Promisification</a></li><li><a href="#microtasks">Microtasks</a></li><li><a href="#asyncawait">Async/await</a></li></ul></li><li><a href="#generators-advanced-iteration">Generators, advanced iteration</a><ul><li><a href="#generators">Generators</a></li><li><a href="#async-iteration-and-generators">Async iteration and generators</a></li></ul></li><li><a href="#modules">Modules</a><ul><li><a href="#modules-introduction">Modules, introduction</a></li><li><a href="#dynamic-imports">Dynamic imports</a></li></ul></li></ul></details><br><br><br><hr><h2 id="javascript-fundamentals">JavaScript Fundamentals</h2><h3 id="variables">Variables</h3><pre><code class="hljs language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// Too old...</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-number">3</span>;
<span class="hljs-keyword">let</span> z = <span class="hljs-number">2</span>;
</code></pre><details><h4 id="let"><code>let</code></h4><p>To create a variable, use the <code>let</code> keyword.</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> message;
message = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">// store the string 'Hello' in the variable named message</span>
</code></pre><h4 id="const"><code>const</code></h4><p>To declare a constant (unchanging) variable, use <code>const</code> instead of <code>let</code>:</p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myBirthday = <span class="hljs-string">'29.08.2000'</span>;

myBirthday = <span class="hljs-string">'15.02.2004'</span>; <span class="hljs-comment">// error, can't reassign the constant!</span>
</code></pre><p>For the object constant variable, we still can reassign its fields, but not the whole object itself.</p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Tu"</span>
}

obj.<span class="hljs-property">name</span> = <span class="hljs-string">"Tuslipid"</span> <span class="hljs-comment">// name: Tuslipid</span>
obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Tusss"</span>
} <span class="hljs-comment">// error, can't reassign the constant!</span>
</code></pre><h4 id="var"><code>var</code></h4><p>In older scripts, you may also find another keyword: <code>var</code> instead of <code>let</code>:</p><pre><code class="hljs language-js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">'Hello'</span>;
</code></pre><p>The <code>var</code> keyword is <em>almost</em> the same as <code>let</code>. It also decalares variable, but in a slightly different, "old-school" way.</p><p>There are subtle differences between <code>let</code> and <code>var</code>, learn more at <a href="#the-old-var">The old "var"</a>.</p><blockquote><p>It is recommended to use <code>const</code>, <code>let</code> instead of <code>var</code>.</p></blockquote></details><br><h3 id="data-types">Data types</h3><p><code>NaN</code>, <code>null</code> and <code>undefined</code></p><details><ul><li><code>NaN</code><br>A computational error. It is a result of an incorrect or and undefined mathematical operation.<br><code>NaN</code> is sticky. Any further mathematical operation on <code>NaN</code> returns <code>NaN</code>.</li></ul><pre><code class="hljs language-js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">"not a number"</span> / <span class="hljs-number">2</span>); <span class="hljs-comment">// NaN, such division is erroneous</span>

<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">NaN</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span>
</code></pre><ul><li><code>null</code><br>In JavaScript, <code>null</code> is not a "reference to a non-existing object" or a "null pointer" like in some other languages.<br>It's just a speical value shich represents "nothing", "empty" or "value unknown".</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-literal">null</span>; <span class="hljs-comment">// age is unknown</span>
</code></pre><ul><li><code>undefined</code><br>The meaning of <code>undefined</code> is "value is not assigned".<br>If a variable is declared, but not assigned, then its value is <code>undefined</code>:</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> age;
<span class="hljs-title function_">alert</span>(age); <span class="hljs-comment">// undefined</span>
</code></pre></details><br><h3 id="interaction">Interaction</h3><ul><li>alert</li><li>prompt</li><li>confirm</li></ul><h3 id="comparisons">Comparisons</h3><p><code>==</code> vs <code>===</code></p><details><p>A strict equality operator <code>===</code> checks the equality without type conversion. In other words, if <code>a</code> and <code>b</code> are different types, then <code>a === b</code> immediately returns <code>false</code> without an attempt to convert them.</p><p>In <code>a == b</code>, if the type of <code>a</code> is different from <code>b</code>, <code>b</code> needs converting to the same type of <code>a</code> then check the equality.</p><pre><code class="hljs language-js"><span class="hljs-number">0</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span>
<span class="hljs-number">0</span> === <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span>
</code></pre></details><br><h3 id="logical-operators">Logical operators</h3><p><code>! (NOT)</code></p><details><p>The boolean NOT operator accepts a single argument and does the following:</p><ol><li>Converts the operand to boolean type: <code>true/false</code>.</li><li>Returns the inverse value. <code>true/false</code> -> <code>false/true</code></li></ol><pre><code class="hljs language-js"><span class="hljs-comment">// The boolean value of all variables except 0, false, null, undefined are TRUE.</span>
!<span class="hljs-literal">true</span>; <span class="hljs-comment">// false</span>
!<span class="hljs-string">"non-empty string"</span>; <span class="hljs-comment">// false</span>
![<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]; <span class="hljs-comment">// false</span>
!!<span class="hljs-string">"non-empty string"</span>; <span class="hljs-comment">// true</span>


!<span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
!<span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
!<span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>
!<span class="hljs-literal">false</span>; <span class="hljs-comment">// true</span>
</code></pre><blockquote><p>!a does not mean <code>a != null</code> or <code>a !== null && a !== undefined</code>.</p></blockquote></details><br><h3 id="nullish-coalescing-operator-">Nullish coalescing operator <code>??</code></h3><p><code>??</code> returns the first arguments if it's not <code>null/undefined</code>. Otherwise, the second one.</p><details><pre><code class="hljs language-js">result = a ?? b;

<span class="hljs-comment">// same as</span>
result = (a != <span class="hljs-literal">null</span>) ? a : b;
</code></pre><p>Comparison with <code>||</code>:</p><ul><li><code>||</code> returns the first <em>truthy</em> value. <code>||</code> doesn't distinguish between <code>false</code>, <code>0</code>, and empty string <code>""</code> and <code>null/undefined</code>.</li><li><code>??</code> returns the first <em>defined</em> value.</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> height = <span class="hljs-number">0</span>;
<span class="hljs-title function_">alert</span>(height || <span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span>
<span class="hljs-title function_">alert</span>(height ?? <span class="hljs-number">100</span>); <span class="hljs-comment">// 0</span>
</code></pre></details><br><h3 id="loop-for">Loop <code>for</code></h3><details><ul><li><code>for</code> (basic)</li><li><code>forEach</code></li></ul><pre><code class="hljs language-js">array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =></span> element);
</code></pre><ul><li><code>for...in</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwnProperties</span>(key)) {
        <span class="hljs-keyword">const</span> element = obj[key];
    }
}
</code></pre><ul><li><code>for...of</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> obj) {
    <span class="hljs-keyword">const</span> value = iterator;
}
</code></pre></details><br><h3 id="functions">Functions</h3><details><ul><li>Function declaration:</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {}
</code></pre><ul><li>Function expression:</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
</code></pre><ul><li>Arrow function:</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) => {}
</code></pre></details><br><br><br><h2 id="code-quality">Code quality</h2><h3 id="polyfills-and-transpilers">Polyfills and transpilers</h3><p><strong>Polyfills</strong><br>The scripts that update/add new functions.</p><p><strong>Transpilers</strong><br>Translate code to a different version.</p><p><br><br></p><h2 id="objects-the-basics">Objects: the basics</h2><h3 id="objects">Objects</h3><ul><li><code>this</code></li></ul><blockquote><p><code>this</code> in arrow function refers to <code>this</code> in surrounding the function</p></blockquote><ul><li>Optional chaining <code>?.</code></li></ul><h3 id="symbol-type">Symbol type</h3><details><ul><li><code>Symbol()</code> Two symbols with the same description are not equal</li><li>Hidden properties<ul><li>In an object literal: need <code>[]</code></li><li>Are skipped by <code>for...in</code></li></ul></li><li>Global symbols<ul><li><code>Symbol.for("id")</code></li><li><code>Symbol.keyFor(sym)</code></li></ul></li></ul></details><br><br><br><h2 id="more-about-data-types">More about data types</h2><h3 id="iterables">Iterables</h3><details><p>Make any object usable in a <code>for...of</code> loop</p><ul><li><code>Symbol.iterator</code></li></ul><pre><code class="hljs language-js">funcName[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">current</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>,
        <span class="hljs-attr">last</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>

        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) {
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++ };
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
            }
        }
    }
}
</code></pre><ul><li>String is iterable</li><li>Calling an iterator explicity</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"Hello"</span>;

<span class="hljs-keyword">let</span> iterator = str[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> result = iterator.<span class="hljs-title function_">next</span>();
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">done</span>) <span class="hljs-keyword">break</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">value</span>);
}
</code></pre><ul><li>Iterables and array-likes Different, array-likes can be not iterable</li><li><code>Array.from</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> arrayLike = {
    <span class="hljs-number">0</span>: <span class="hljs-string">"hello"</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">"world"</span>,
    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>
};
<span class="hljs-keyword">let</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
</code></pre></details><br><h3 id="objectkeys-values-entries">Object.keys, values, entries</h3><details><ul><li><code>Object.keys</code></li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)
<span class="hljs-comment">// Return [key1, key2,...]</span>
</code></pre><ul><li><code>Object.values</code></li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj)
<span class="hljs-comment">// Return [value1, value2, ...]</span>
</code></pre><ul><li><code>Object.entries</code></li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)
<span class="hljs-comment">// Return [[key1, value1], [key2, value1], ...]</span>
</code></pre><ul><li><code>Object.fromEntries</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> array = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj);
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(array);
<span class="hljs-comment">// Return the object from array</span>
</code></pre><ul><li>Transforming objects</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> originalObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(initialObj).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =></span> [entry[<span class="hljs-number">0</span>], entry[<span class="hljs-number">1</span>]]);
);
</code></pre></details><br><h3 id="destructuring-assignment">Destructuring assignment</h3><details><ul><li>Array destructuring</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">"Khoa"</span>, <span class="hljs-string">"Tu"</span>];
<span class="hljs-keyword">let</span> [word1, word2] = arr; <span class="hljs-comment">// word1 = "Khoa", word2 = "Tu"</span>
</code></pre><ul><li>The rest <code>...</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> [word1, word2, ...rest] = [] <span class="hljs-comment">// rest is a new array of the rest element</span>
</code></pre><ul><li>Default values</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> [name=<span class="hljs-string">"Guest"</span>, surname=<span class="hljs-string">"Anonymous"</span>] = [<span class="hljs-string">"Julius"</span>];
<span class="hljs-comment">// name="Julius" (from array)</span>
<span class="hljs-comment">// surname="Anonymous" (default used)</span>
</code></pre><ul><li>Object destructuring</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> {field1, field2} = obj;
<span class="hljs-keyword">let</span> {<span class="hljs-attr">field1</span>: f1, <span class="hljs-attr">field2</span>: f2} = obj;
<span class="hljs-keyword">let</span> {value1=val1, value2=val2, field} = obj
<span class="hljs-keyword">let</span> {field1, ...rest} = obj;
</code></pre><ul><li>Nested destructuring</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> options = {
    <span class="hljs-attr">size</span>: {
        <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
        <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
    },
    <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
    <span class="hljs-attr">extrat</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-comment">// Destructuring</span>
<span class="hljs-keyword">let</span> {
    <span class="hljs-attr">size</span>: {
        width,
        height
    },
    <span class="hljs-attr">items</span>: [item1, item2],
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Menu"</span> <span class="hljs-comment">// not present in the object</span>
} = options;
</code></pre></details><br><h3 id="date-and-time">Date and time</h3><details><ul><li>Date before 01/01/1970 has negative timestamp</li><li>Autocorrection</li><li>Benchmarking: <code>date1.getTime()-date2.getTime()</code> is faster than <code>date1-date2</code></li><li>Date.parse from a string:<ul><li>The string format should be: <code>YYYY-MM-DDTHH:mm:ss.sssZ</code></li><li>Shorter variants are also possible: <code>YYYY-MM-DD</code>, <code>YYYY-MM</code>, <code>YYYY</code></li></ul></li></ul></details><br><h3 id="json-methods-tojson">JSON methods, toJSON</h3><details><ul><li><code>JSON.stringify</code>: to string</li><li><code>JSON.parse</code>: to object</li><li>JSON supports following data types:<ul><li>Objects</li><li>Arrays</li><li>Primitives:<ul><li>strings</li><li>numbers</li><li>boolean</li><li>null</li></ul></li></ul></li><li>JSON skips some object properties:<ul><li>Function</li><li>Symbolic keys and values</li><li>Properties that store <code>undefined</code></li></ul></li><li>Limitation: there must be no circular references</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> room = {};
<span class="hljs-keyword">let</span> meetup = {};
meetup.<span class="hljs-property">place</span> = room; <span class="hljs-comment">// meetup references room</span>
room.<span class="hljs-property">occupiedBy</span> = meetup; <span class="hljs-comment">// roon references meetup</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(meetup) <span class="hljs-comment">// Error</span>
</code></pre><ul><li>Full syntax</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value[, replacer, space])
</code></pre><ul><li>Excluding and transforming: replacer</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replacer</span>(<span class="hljs-params">key, value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
    <span class="hljs-keyword">return</span> (key === <span class="hljs-string">'a_field_we_want_to_exclude'</span>) ? <span class="hljs-literal">undefined</span> : value;
}
</code></pre><ul><li>Formatting: space</li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">strignify</span>(user, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// format 2 space</span>
</code></pre><ul><li>Custom <code>toJSON()</code> method</li><li><code>JSON.parse</code></li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str, [reviver]);
</code></pre><ul><li>Using reviver</li></ul><pre><code class="hljs language-js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str, <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) {
    <span class="hljs-comment">// A date string may not be a Date object so we have to </span>
    <span class="hljs-comment">// update it to a Date object</span>
    <span class="hljs-keyword">if</span> (key == <span class="hljs-string">'date'</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(value);
    <span class="hljs-keyword">return</span> value;
})
</code></pre></details><br><br><br><h2 id="advanced-working-with-functions">Advanced working with functions</h2><h3 id="rest-parameters-and-spread-syntax">Rest parameters and spread syntax</h3><details><ul><li>Rest parameters <code>...</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">...args</span>) {} <span class="hljs-comment">// args is the name of the array -> parameters array</span>
</code></pre><blockquote><p>The rest parameters must be at the end</p></blockquote><ul><li>The <code>arguments</code> variable<br>A special array-like object that contains all arguments by their index</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);
}

<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// Show 1, 2</span>
<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Show 1, undefined (no second argument)</span>
</code></pre><blockquote><p>Arrow functions do not have <code>arguments</code></p></blockquote><ul><li>Spread syntax</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr); <span class="hljs-comment">// 3</span>

<span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr, ...arr1); <span class="hljs-comment">// 4</span>
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr,<span class="hljs-number">5</span>,...arr1,<span class="hljs-number">6</span>); <span class="hljs-comment">// 6</span>
</code></pre><blockquote><p>The spread syntax internally uses iterators to gather elements, the same way as <code>for...of</code> does. So it can be used with any iterable.</p></blockquote><ul><li>Copy an array/object</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arrCopy = [...arr]; <span class="hljs-comment">// Spread the array into a list of parameters </span>
                        <span class="hljs-comment">// then put the result into a new array</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr === arrCopy) <span class="hljs-comment">// false</span>
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };
<span class="hljs-keyword">let</span> objCopy = { ...obj };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj === objCopy); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj) === <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(objCopy)); <span class="hljs-comment">// true</span>
</code></pre></details><br><h3 id="the-old-var">The old <code>var</code></h3><details><ul><li><code>var</code> has no block scope</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> test = <span class="hljs-literal">true</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">// true</span>
</code></pre><ul><li><code>var</code> tolerates redeclarations</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">var</span> user = <span class="hljs-string">"Tus"</span>;
<span class="hljs-keyword">var</span> user = <span class="hljs-string">"Tu"</span>;
<span class="hljs-comment">// Works fine</span>
</code></pre><ul><li><code>var</code> variables can be declared below their use</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) {
    phrase = <span class="hljs-string">"Hello"</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(phrase);
    <span class="hljs-keyword">var</span> phrase;
}
</code></pre><blockquote><p>Declarations are hoisted, but assignments are not</p></blockquote><ul><li>IIFE<br>In the past, as there was only <code>var</code>, and it has no block-level visibility, programmers invented a way to emulate it. What they did was called "immediately-invoked function expressions" (IIFE).</li></ul><pre><code class="hljs language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Parentheses around the function'</span>);
})();

(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Parentheses around the whole thing'</span>);
}());

!<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Bitwise NOT operator starts the expression'</span>);
}();

+<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Unary plus starts the expression'</span>);
}();
</code></pre></details><br><h3 id="global-object">Global object</h3><pre><code class="hljs language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">globalObj</span> = {}
</code></pre><h3 id="the-new-function-syntax">The <code>new Function</code> syntax</h3><p>Useful when creating function from string is needed</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>([arg1, arg2, ...argN], functionBody);
</code></pre><h3 id="scheduling-settimeout-and-setinterval">Scheduling: <code>setTimeout</code> and <code>setInterval</code></h3><details><ul><li><code>setTimeout</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(func|code, [delay], [arg1], [arg2], ...);
</code></pre><ul><li>Canceling with <code>clearTimeout</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(...);
<span class="hljs-built_in">clearTimeout</span>(timerId);
</code></pre><ul><li><code>setInterval</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(func|code, [delay], [arg1], [arg2], ...)
</code></pre><ul><li>Canceling with <code>TimerId</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'clicl'</span>), <span class="hljs-number">2000</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> { <span class="hljs-built_in">clearInterval</span>(timerId); <span class="hljs-title function_">alert</span>(<span class="hljs-string">'stop'</span>); }, <span class="hljs-number">5000</span>);
</code></pre><ul><li>Nested <code>setTimeout</code></li></ul><pre><code class="hljs language-js"><span class="hljs-comment">/** instead of
 * let timerId = setInterval(() => alert('tick'), 2000);
**/</span>

<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'tick'</span>);
    timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">2000</span>);
}, <span class="hljs-number">2000</span>);
</code></pre><ul><li>Zero delay <code>setTimeout</code><br>This schedules the execution of <code>func</code> as soon as possible. But the scheduler will invoke it only after ther currently executing script is complete.</li></ul><pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">"World"</span>));

<span class="hljs-title function_">alert</span>(<span class="hljs-string">"hello"</span>);
</code></pre></details><br><h3 id="decorators-and-forwarding-callapply">Decorators and forwarding, call/apply</h3><details><h4 id="transparent-caching">Transparent caching</h4><p>Let's say we have a function <code>slow(x)</code> which is CPU-heavy, but its results are stable. In other words, for the same <code>x</code> it always return the same result.</p><p>If the function is called often, we may want to cache (remember) the results to avoid spending extra-time on recalculations.</p><p>Instead of adding that functionality into <code>slow()</code> we'll create a wrapper function, that adds caching</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">slow</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-comment">// there can be a heavy CPU-intensive job here</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Called with <span class="hljs-subst">${x}</span>`</span>);
    <span class="hljs-keyword">return</span> x;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">cachingDecorator</span>(<span class="hljs-params">func</span>) {
    <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) {
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(x)) {         <span class="hljs-comment">// if there's such key in cache </span>
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(x);    <span class="hljs-comment">// read the result from it</span>
        }

        <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">func</span>(x);       <span class="hljs-comment">// otherwise call func</span>

        cache.<span class="hljs-title function_">set</span>(x, result);       <span class="hljs-comment">// and cache (remember) the result</span>
        <span class="hljs-keyword">return</span> result;
    }
}

slow = <span class="hljs-title function_">cachingDecorator</span>(slow);

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">slow</span>(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// slow(1) is cached and the result returned</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">"Again: "</span> + <span class="hljs-title function_">slow</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// slow(1) result returned from cache</span>
</code></pre><h4 id="using-funccall-for-the-context">Using <code>func.call</code> for the context</h4><p>The caching decorator mentioned above is not suited to work with object methods.</p><p>For instance, in the code below <code>worker.slow()</code> stops working after the decoration:</p><pre><code class="hljs language-js"><span class="hljs-comment">// we'll make worker.slow caching</span>
<span class="hljs-keyword">let</span> worker = {
    <span class="hljs-title function_">someMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-title function_">slow</span>(<span class="hljs-params">x</span>) {
        <span class="hljs-comment">// scary CPU-heavy task here</span>
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Called with "</span> + x);
        <span class="hljs-keyword">return</span> x * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">someMethod</span>(); <span class="hljs-comment">// (*)</span>
    }
}

<span class="hljs-comment">// same code as before</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">cachingDecorator</span>(<span class="hljs-params">func</span>) {
    <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) {
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(x)) <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(x);
        <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">func</span>(x); <span class="hljs-comment">// (**)</span>
        cache.<span class="hljs-title function_">set</span>(x, result);
        <span class="hljs-keyword">return</span> result;
    };
}

<span class="hljs-title function_">alert</span>( worker.<span class="hljs-title function_">slow</span>(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// the original method works</span>

worker.<span class="hljs-property">slow</span> = <span class="hljs-title function_">cachingDecorator</span>(worker.<span class="hljs-property">slow</span>); <span class="hljs-comment">// now make it caching</span>

<span class="hljs-title function_">alert</span>( worker.<span class="hljs-title function_">slow</span>(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// Error: Canor read property 'someMethod` of undefined</span>
</code></pre><p>The error occurs in the line <code>(*)</code> that tries to access <code>this.someMethod</code> and fails.</p><p>The reason is that the wrapper calls the original function as <code>func(x)</code> in the line <code>(**)</code>. And, when called like that, the function gets <code>this = undefined</code>.</p><p><strong>Let's fix it.</strong> There's a special built-in function method <code>func.call(context, ...args)</code> that allows to call a funciton explicitly setting <code>this</code>.</p><pre><code class="hljs language-js">func.<span class="hljs-title function_">call</span>(context, arg1, arg2, ...)

<span class="hljs-comment">// These 2 calls do almost the same</span>
<span class="hljs-title function_">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
func.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}

<span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };
<span class="hljs-keyword">let</span> admin = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Admin"</span> };

<span class="hljs-comment">// use call to pass different objects as "this"</span>
sayHi.<span class="hljs-title function_">call</span>(user);
sayHi.<span class="hljs-title function_">call</span>(admin);
</code></pre><p>In our case, we can <code>call</code> in the wrapper to pass the context to the original function:</p><pre><code class="hljs language-js"><span class="hljs-comment">// before: let result = func(x);</span>
<span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, x);
</code></pre><h4 id="going-multi-argument">Going multi-argument</h4><p>Till now the <code>cachingDecorator</code> was working only with single-argument functions. Now how to cache the multi-argument <code>worker.slow</code> method?</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> worker = {
    <span class="hljs-title function_">slow</span>(<span class="hljs-params">min, max</span>) {
        <span class="hljs-keyword">return</span> min + max; <span class="hljs-comment">// scary CPU-hogger is assumed</span>
    }
};

<span class="hljs-comment">// cachingDecorator needs modifying</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">cachingDecorator</span>(<span class="hljs-params">func, hash</span>) {
    <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> key = <span class="hljs-title function_">hash</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// (*)</span>
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);
        }

        <span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// (**)</span>

        cache.<span class="hljs-title function_">set</span>(key, result);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">args</span>) {
    <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>] + <span class="hljs-string">','</span> + args[<span class="hljs-number">1</span>];
}

<span class="hljs-comment">// should remember same-argument calls</span>
worker.<span class="hljs-property">slow</span> = <span class="hljs-title function_">cachingDecorator</span>(worker.<span class="hljs-property">slow</span>, hash);

<span class="hljs-title function_">alert</span>(worker.<span class="hljs-title function_">slow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// works</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-string">"Again "</span> + worker.<span class="hljs-title function_">slow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// same (cached)</span>
</code></pre><h4 id="funcapply"><code>func.apply</code></h4><p>Instead of <code>func.call(this, ...arguments)</code> we could use <code>func.apply(this, arguments)</code>.</p><pre><code class="hljs language-js">func.<span class="hljs-title function_">apply</span>(context, args)
</code></pre><p>These two calls are almost equivalent:</p><pre><code class="hljs language-js">func.<span class="hljs-title function_">call</span>(context, ...args);
func.<span class="hljs-title function_">apply</span>(context, args);
</code></pre></details><br><h3 id="function-binding">Function binding</h3><details><ul><li>Losing <code>this</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">firstname</span>: <span class="hljs-string">"John"</span>;
    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.firstname}</span>!`</span>);
    }
};

<span class="hljs-built_in">setTimeout</span>(user.<span class="hljs-property">sayHi</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// Hello, undefined!</span>
</code></pre><ul><li>Solution 1: a wrapper</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">firstname</span>: <span class="hljs-string">"John"</span>;
    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.firstname}</span>!`</span>);
    }
};

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello, John!</span>
}, <span class="hljs-number">1000</span>);
</code></pre><ul><li>Solution 2: bind</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> boundFunc = func.<span class="hljs-title function_">bind</span>(context);
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">firstname</span>: <span class="hljs-string">"John"</span>;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);
}

<span class="hljs-keyword">let</span> funcUser = func.<span class="hljs-title function_">bind</span>(usert);
<span class="hljs-title function_">funcUser</span>(); <span class="hljs-comment">// John</span>
</code></pre><ul><li>Partial functions<br>The full syntax of <code>bind</code>:</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> bound = func.<span class="hljs-title function_">bind</span>(context, [arg1], [arg2], ...);
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a*b;
}

<span class="hljs-keyword">let</span> double = mul.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// = mul(2, 3) = 6</span>
</code></pre><ul><li>Going partial without context<br>What if we'd like to fix some arguments, but not the context <code>this</code>?<br>The native <code>bind</code> does not allow that.</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">func, ...argsBound</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...argsBound, ...args);
    }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>,
    <span class="hljs-title function_">say</span>(<span class="hljs-params">time, phrase</span>) {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`[<span class="hljs-subst">${time}</span>] <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.firstName}</span>: <span class="hljs-subst">${phrase}</span>!`</span>);
    }
};

<span class="hljs-comment">// add a partial method with fixed time</span>
user.<span class="hljs-property">sayNow</span> = <span class="hljs-title function_">partial</span>(user.<span class="hljs-property">say</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getHours</span>() + <span class="hljs-string">':'</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getMinutes</span>());

user.<span class="hljs-title function_">sayNow</span>(<span class="hljs-string">"Hello"</span>);
<span class="hljs-comment">// [10:00] John: Hello!</span>
</code></pre></details><br><br><br><h2 id="object-properties-configuration">Object properties configuration</h2><h3 id="property-flags-and-descriptors">Property flags and descriptors</h3><details><p><code>Propety flags</code><br>Object properties, besides a <code>value</code>, have three special attributes:</p><pre><code>+ `writable`
+ `enumerable`
+ `configurable`
</code></pre><p>Method <code>Object.getOwnPropertyDescriptor</code> allows to query the full information about a property</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, propertyName);
</code></pre><p>To change the flags, we can use <code>Object.defindProperty</code></p><pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, propertyName, descriptor);
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user, <span class="hljs-string">"name"</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-string">"John"</span>
});
</code></pre><p><code>Object.defineProperties</code> help an object to define multiple properties</p><pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, {
    <span class="hljs-attr">prop1</span>: descriptor1,
    <span class="hljs-attr">prop2</span>: descriptor2,
    <span class="hljs-comment">// ...</span>
})
</code></pre></details><br><br><br><h2 id="prototypes-inheritance">Prototypes, inheritance</h2><h3 id="prototypal-inheritance">Prototypal inheritance</h3><details><ul><li><code>[[Prototype]]</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> animal = {
    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = {
    <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>
};

rabbit.<span class="hljs-property">__proto__</span> = animal;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">eats</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">jumps</span>); <span class="hljs-comment">// true</span>
</code></pre><blockquote><p>The <code>__proto__</code> must be an object or null</p></blockquote></details><br><h3 id="fprototype">F.prototype</h3><details><p>Used when a object is created by a constructor function, like <code>new F()</code></p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> animal = {
    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">"White Rabbit"</span>); <span class="hljs-comment">// When a new Rabbit is created,</span>
                                         <span class="hljs-comment">// assign its [[Prototype]] to animal</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">eats</span>); <span class="hljs-comment">// true</span>
</code></pre><ul><li>Default F.prototype, constructor property</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>) {};

<span class="hljs-comment">/* default prototype
Rabbit.prototype = { constructor: Rabbit };
*/</span>
</code></pre></details><br><h3 id="native-prototypes">Native prototypes</h3><details><ul><li><code>Object.prototype</code></li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj = {};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">toString</span> === obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">toString</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">// true</span>
</code></pre><blockquote><p>There is no more <code>[[Prototype]]</code> in the chain above <code>Object.prototype</code></p></blockquote><ul><li>Other built-in prototypes<br>Other built-in objects such as <code>Array</code>, <code>Date</code>, <code>Function</code>, etc... also keep methods in prototypes</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">// null</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 1,2,3 &lt;-- the result of Array.prototype.toString</span>
</code></pre><ul><li>Changing native prototypes</li></ul><pre><code class="hljs language-js"><span class="hljs-comment">// show becomes available to all strings</span>
<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>);
}

<span class="hljs-string">"Boom!"</span>.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// Boom!</span>
</code></pre><ul><li>Borrowing from prototypes</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-number">0</span>: <span class="hljs-string">"Hello"</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">"World!"</span>,
    length = <span class="hljs-number">2</span>,
};
obj.<span class="hljs-property">join</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>)); <span class="hljs-comment">// Hello,World!</span>
</code></pre></details><br><br><br><h2 id="classes">Classes</h2><p>In JavaScript, a class is a kind of function.</p><details><p>What <code>class A{...}</code> construct really does is:</p><ol><li>Creates a function named <code>A</code>, that becomes the result of the class declaration. The function code is taken from the <code>constructor</code> method.</li><li>Stores class methods in <code>A.prototype</code></li></ol><p><strong>Basic syntax</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    prop = value; <span class="hljs-comment">// property</span>

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...</span>) { <span class="hljs-comment">// constructor</span>
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-title function_">method</span>(<span class="hljs-params">...</span>) {} <span class="hljs-comment">// method</span>

    <span class="hljs-keyword">get</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) {} <span class="hljs-comment">// getter method</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) {} <span class="hljs-comment">// setter method</span>

    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {} <span class="hljs-comment">// method with computed name (symbol here)</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre></details><br><br><br><h2 id="error-handling">Error handling</h2><details><pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// run this code</span>
} <span class="hljs-keyword">catch</span>(err) {
    <span class="hljs-comment">// If an error happened, then jump here</span>
    <span class="hljs-comment">// err is the error object</span>
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// do in any case after try/catch</span>
}
</code></pre></details><br><h3 id="custom-errors-extending-error">Custom errors, extending Error</h3><details><ul><li>Extending Error<br>The <code>Error</code> class is built-in, but here's its approximation code so we can understand what we're extending</li></ul><pre><code class="hljs language-js"><span class="hljs-comment">// The "pseudocode" for the built-in Error class defined by JavaScript itself</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"Error"</span>; <span class="hljs-comment">// (different names for different built-in error classes)</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">call</span> <span class="hljs-attr">stack</span>></span>; // non-standard, but most environments support it
    }
}
</span></code></pre><p>Inherit <code>ValidationError</code> from it:</p><pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) {
        <span class="hljs-variable language_">super</span>(message);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"ValidationError"</span>;
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationError</span>(<span class="hljs-string">"Whoops!"</span>);
}

<span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">test</span>();
} <span class="hljs-keyword">catch</span>(err) {
    <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// Whoops!</span>
    <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">name</span>); <span class="hljs-comment">// ValidationError</span>
    <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">stack</span>); <span class="hljs-comment">// a list of nested calles with lines numbers for each</span>
}
</code></pre><p>Further inheritance:</p><pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertyRequiredError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ValidationError</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">property</span>);
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">"No property: "</span> + property);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">"PropetyRequiredError"</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = property;
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateUser</span>(<span class="hljs-params">json</span>) {
    <span class="hljs-keyword">let</span> user = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json);

    <span class="hljs-keyword">if</span> (!user.<span class="hljs-property">age</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyRequiredError</span>(<span class="hljs-string">"age"</span>);
    }
    <span class="hljs-keyword">if</span> (!user.<span class="hljs-property">name</span>) {
        <span class="hljs-keyword">throw</span> mew <span class="hljs-title class_">PropertyRequiredError</span>(<span class="hljs-string">"name"</span>);
    }

    <span class="hljs-keyword">return</span> user;
}

<span class="hljs-comment">// Example with try...catch</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> user = <span class="hljs-title function_">validateUser</span>(<span class="hljs-string">'{ "age": 25 }'</span>);
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ValidationError</span>) {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Invalid data: "</span> + err.<span class="hljs-property">message</span>);
        <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">name</span>); <span class="hljs-comment">// PropertyRequiredError</span>
        <span class="hljs-title function_">alert</span>(err.<span class="hljs-property">property</span>); <span class="hljs-comment">// name</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SyntaxError</span>) {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"JSON Syntax Error: "</span> + err.<span class="hljs-property">message</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> err;
    }
}
</code></pre><p>Wrapping exceptions:<br>There can be more types of errors and we may not want to check for all error types one-by-one everytime, so we may need an exception wrapper.</p><pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message, cause</span>) {
        <span class="hljs-variable language_">super</span>(message);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cause</span> = cause;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'ReadError'</span>;
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readUser</span>(<span class="hljs-params">json</span>) {
    <span class="hljs-keyword">let</span> user;

    <span class="hljs-keyword">try</span> {
        user = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json);
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SyntaxError</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadError</span>(<span class="hljs-string">'Syntax Error'</span>, err);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> err;
        }
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">validateUser</span>(user);
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ValidationError</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadError</span>(<span class="hljs-string">"Validation Error"</span>, err);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> err;
        }
    }
}

<span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">readUser</span>(<span class="hljs-string">'{bad json}'</span>);
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ReadError</span>) {
        <span class="hljs-title function_">alert</span>(e);
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Original error: "</span> + e.<span class="hljs-property">cause</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> e;
    }
}
</code></pre></details><br><br><br><h2 id="promises-asyncawait">Promises, async/await</h2><h3 id="introduction-callbacks">Introduction: callbacks</h3><p>Many functions are provided by JavaScript host environments that allow you to schedule <em>asynchronous</em> actions. In other words, actions that we initiate now, but they finish later.</p><details><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src</span>) {
    <span class="hljs-comment">// creates a &lt;script> tag and append it to the page</span>
    <span class="hljs-comment">// this causes the script with given src to start loading and run</span>
    <span class="hljs-comment">// when complete</span>
    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
    script.<span class="hljs-property">src</span> = src;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);
}

<span class="hljs-comment">// load and execute the script at the given path</span>
<span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script.js'</span>); <span class="hljs-comment">// the script has "function newFunction() {}"</span>
<span class="hljs-comment">// the code below loadScript doesn't wait for the script loading to finish</span>
<span class="hljs-title function_">newFunction</span>(); <span class="hljs-comment">// no such function!</span>
</code></pre><p>Let's add a <code>callback</code> function as a second argument to <code>loadScript</code> that should execute when the script loads:</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) {
    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
    script.<span class="hljs-property">src</span> = src;

    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =></span> <span class="hljs-title function_">callback</span>(script);

    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);
}

<span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// the callback runs after the script is loaded</span>
    <span class="hljs-title function_">newFunction</span>(); <span class="hljs-comment">// so now it works</span>
    ...
});
</code></pre><br><p><strong>Callback in callback</strong><br>How can we load two scripts sequentially: the first one, and then the second one after it?<br>The natural solution would be to put the second <code>loadScript</code> call inside the callback</p><pre><code class="hljs language-js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) {

  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Cool, the <span class="hljs-subst">${script.src}</span> is loaded, let's load one more`</span>);

  <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script2.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Cool, the second script is loaded`</span>);
  });

});
</code></pre><p>After the outer <code>loadScript</code> is complete, the callback initiates the inner one.<br>What if we want one more script...?</p><pre><code class="hljs language-js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) {
    <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script2.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) {
        <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script3.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) {
            <span class="hljs-comment">// ... continue after all scripts are loaded</span>
        })
    })
})
</code></pre><br><p><strong>Handling errors</strong><br>Here's an improved version of <code>loadScript</code> that tracks loading errors</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) {
    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
    script.<span class="hljs-property">src</span> = src;

    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =></span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, script);
    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =></span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));

    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);
}

<span class="hljs-comment">// The usage</span>
<span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'/my/script.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, script</span>) {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-comment">// handle error</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// script loaded successfully</span>
    }
});
</code></pre><br><p><strong>Pyramid of Doom</strong></p><pre><code class="hljs language-js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'1.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-title function_">handleError</span>(error);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'2.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-title function_">handleError</span>(error);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// ...</span>
                <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'3.js'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) {
                    <span class="hljs-keyword">if</span> (error) {
                        <span class="hljs-title function_">handleError</span>(error);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// ...continue after all scripts are loaded</span>
                    }
                })
            }
        })
    }
})
</code></pre><p>Callbacks hell! We can try to alleviate the problem by making every action a standalone function</p><pre><code class="hljs language-js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'1.js'</span>, step1);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">error, script</span>) {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-title function_">handleError</span>(error);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'2.js'</span>, step2);
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">error, script</span>) {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-title function_">handleError</span>(error);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">'3.js'</span>, step3);
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params">error, script</span>) {
    <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-title function_">handleError</span>(error);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// ...continue after all scripts are loaded</span>
    }
}
</code></pre></details><br><h3 id="promise">Promise</h3><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-comment">// executor</span>
});
</code></pre><details><p>The <code>promise</code> object returned by the <code>new Promise</code> constructor has these internal properties</p><ul><li><code>state</code> - initially <code>"pending"</code>, then changes to either <code>"fulfilled"</code> when <code>resolve</code> is called or <code>"rejected"</code> when <code>reject</code> is called.</li><li><code>result</code> - initially <code>undefined</code>, then changes to <code>value</code> when <code>resolve(value)</code> is called or <code>error</code> when <code>reject(error)</code> is called.</li></ul><blockquote><p>Only the first call of <code>resolve/reject</code> is taken into account. Further calls are ignored.</p></blockquote><p><strong>Consumers: then, catch</strong><br><code>then</code></p><pre><code class="hljs language-js">promise.<span class="hljs-title function_">then</span>(
    <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) { <span class="hljs-comment">/* handle a successful result */</span>},
    <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) { <span class="hljs-comment">/* handle an error */</span> }
);
</code></pre><p><code>catch</code> - if we interested only in errors</p><pre><code class="hljs language-js">promise.<span class="hljs-title function_">catch</span>(errorHandlingFunction);
</code></pre><p><strong>Cleanup: finally</strong><br>The call <code>.finally(f)</code> is similar to <code>.then(f, f)</code> in the sense that <code>f</code> runs always, when the promise is settled: be it resolve or reject.</p><pre><code class="hljs language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-comment">/* do sth */</span>
})
<span class="hljs-comment">// runs when the promise is settled, doesn't matter successfully or not</span>
.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> stop loading indicator)
<span class="hljs-comment">// so the loading indicator is always stopped before we go on</span>
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> show result, <span class="hljs-function"><span class="hljs-params">err</span> =></span> show error);
</code></pre></details><br><h3 id="promise-chaining">Promise chaining</h3><details><pre><code class="hljs language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {
    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 4</span>
    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
})
</code></pre></details><br><h3 id="error-handling-with-promises">Error handling with promises</h3><pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://no-such-server.blabla'</span>) <span class="hljs-comment">// rejects</span>
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-title function_">alert</span>(err)) <span class="hljs-comment">// TypeError: failed to fetch</span>
</code></pre><details><p><strong>Implicit try...catch</strong><br>This code:</p><pre><code class="hljs language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>);
}).<span class="hljs-title function_">catch</span>(alert); <span class="hljs-comment">// Error: Whoops!</span>
</code></pre><p>...Works exactly the same as this:</p><pre><code class="hljs language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>));
}).<span class="hljs-title function_">catch</span>(alert); <span class="hljs-comment">// Error: Whoops!</span>
</code></pre><p>The "invisible <code>try...catch</code>" around the executor automatically catches the error and turns it into rejected promise.</p><p><strong>Rethrowing</strong><br>In a promise we may analyze the error and rethrow it like a regular <code>try...catch</code> if it can't be handled.</p><pre><code class="hljs language-js"><span class="hljs-comment">// the execution: catch -> catch</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>);
}).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">URIError</span>) {
        <span class="hljs-comment">// Handle it</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"Can't handle such error"</span>);
        <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// Throwing this or another error jumps to the next catch</span>
    }
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* Doesn't run here */</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`The unknown error has occured: <span class="hljs-subst">${error}</span>`</span>);
    <span class="hljs-comment">// Don't return anything => execution goes the normal way</span>
});
</code></pre></details><br><h3 id="promise-api">Promise API</h3><details><ul><li><strong>Promise.all</strong><br><code>Promise.all</code> takes an iterable (ususally, an array of promises) and returns a new promise.<br>The new promise resolves when all listed promises are resolved, and the array of their results becomes its result.</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(iterable)
</code></pre><p>For instance, the <code>Promise.all</code> below settles after 3 seconds, and then it result is an array <code>[1,2,3]</code></p><pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">3000</span>)), <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-number">2000</span>)), <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">1000</span>))  <span class="hljs-comment">// 3</span>
]).<span class="hljs-title function_">then</span>(alert); <span class="hljs-comment">// 1,2,3 when promises are ready</span>
</code></pre><blockquote><p>If one promise rejects, <code>Promise.all</code> immediately rejects, completely forgetting about the other ones in the list. Their result are ignored.</p></blockquote><ul><li><strong>Promise.allSettled</strong></li></ul><blockquote><p>This is a recent addition to the language. Old browsers may need polyfills.</p></blockquote><p>For example, we'd like to fetch the information about multiple users. Even if one request fails, we're still interested in the others.</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> urls = [
    <span class="hljs-string">'https://api.github.com/users/iliakan'</span>,
    <span class="hljs-string">'https://api.github.com/users/remy'</span>,
    <span class="hljs-string">'https://no-such-url'</span>
];

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(urls.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">url</span> =></span> <span class="hljs-title function_">fetch</span>(url)))
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =></span> { <span class="hljs-comment">// (*)</span>
    results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, num</span>) =></span> {
        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">"fulfilled"</span>) {
            <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">${urls[num]}</span>: <span class="hljs-subst">${result.value.status}</span>`</span>);
        }
        <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">"rejected"</span>) {
            <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">${urls[num]}</span>: <span class="hljs-subst">${result.reason}</span>`</span>);
        }
    });
});
</code></pre><p>The <code>results</code> in the line <code>(*)</code> will be</p><pre><code class="hljs language-js">[
    {<span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: ...response...},
    {<span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: ...response...},
    {<span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: ...error object...}
]
</code></pre><ul><li><strong>Promise.race</strong><br>Similar to <code>Promise.all</code>, but waits only for the first settled promise and gets its result (or error).</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(iterable);
</code></pre><pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>)),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>)), <span class="hljs-number">2000</span>)),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>))
]).<span class="hljs-title function_">then</span>(alert); <span class="hljs-comment">// 1</span>
</code></pre><ul><li><strong>Promise.any</strong><br>Similar to <code>Promise.race</code>, but waits only for the first fulfilled promise and gets it result. If all of the given promises are rejected, the the returned promise is rejected with <code>AggregateError</code>.</li></ul><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(iterable);
</code></pre><pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>)), <span class="hljs-number">1000</span>)),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2000</span>)),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>))
]).<span class="hljs-title function_">then</span>(alert); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// When all promises fail</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Ouch!"</span>)), <span class="hljs-number">1000</span>)),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Error!"</span>)), <span class="hljs-number">2000</span>))
]).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// AggregateError</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Error: Ouch!</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Error: Error!</span>
});
</code></pre><ul><li><strong>Promise.resolve/reject</strong><ul><li><code>Promise.resolve(value)</code> is same as <code>new Promise(resolve => resolve(value))</code>.</li><li><code>Promise.reject(value)</code> is same as <code>new Promise((resolve, reject) => reject(error))</code>.</li></ul></li></ul></details><br><h3 id="promisification">Promisification</h3><p>"Promisification" is a long word for a simple transformation - the conversion of a function that accepts a callback into a function that returns a promise.</p><details><p>For instance, we have <code>loadScript(src, callback)</code> from <a href="#introduction-callbacks">Introduction: callbacks</a></p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) {
    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
    script.<span class="hljs-property">src</span> = src;

    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =></span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, script);
    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =></span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));

    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);
}
</code></pre><p>We can promisify like this</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> loadScriptPromise = <span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
        <span class="hljs-title function_">loadScript</span>(src, <span class="hljs-function">(<span class="hljs-params">err, script</span>) =></span> {
            <span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);
            <span class="hljs-keyword">else</span> <span class="hljs-title function_">resolve</span>(script);
        })
    })
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-title function_">loadScriptPromise</span>(<span class="hljs-string">'path/script.js'</span>).<span class="hljs-title function_">then</span>(...);
</code></pre><p>The new function is a wrapper arount the original <code>loadScript</code> function. It calls it providng its own callback that translates to promise <code>resolve/reject</code>.</p><p>In practice we may need to promisify more than one function, so it makes sense to use a helper. We'll call it <code>promisify(f)</code>: it accepts a to-promisify function <code>f</code> and returns a wrapper function.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(<span class="hljs-params">f</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) { <span class="hljs-comment">// return a wrapper-function</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">err, result</span>) { <span class="hljs-comment">// our custom callback for f</span>
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-title function_">reject</span>(err);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-title function_">resolve</span>(result);
                }
            }

            args.<span class="hljs-title function_">push</span>(callback); <span class="hljs-comment">// append our custon callback to the end of f arguments</span>

            f.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args); <span class="hljs-comment">// call the original function</span>
        });
    };
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">let</span> loadScriptPromise = <span class="hljs-title function_">promisify</span>(loadScript);
<span class="hljs-title function_">loadScriptPromise</span>(...).<span class="hljs-title function_">then</span>(...);
</code></pre><p>Here, <code>promisify</code> assumes that the original function expects a callback with exactly two arguments <code>(err, result)</code>. That's what we encounter most often. Then our custom callback is in exactly the right format, and <code>promisify</code> works great for such a case.</p><p>But what if the original <code>f</code> expects a callback with more arguments `callback(err, res1, res2, ...)?</p><p>We can improve our helper. Let's make a more advanced version of <code>promisify</code>.</p><ul><li>When called as <code>promisify(f)</code> it should work similar to the version above.</li><li>When called as <code>promisify(f, true)</code>, it should return the promise that resolves with the array of callback results. That's exactly for callbacks with many arguments.</li></ul><pre><code class="hljs language-js"><span class="hljs-comment">// promisify(f, true) to get array of results</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(<span class="hljs-params">f, manyArgs = <span class="hljs-literal">false</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">err, ...results</span>) { <span class="hljs-comment">// our custom callback for f</span>
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-title function_">reject</span>(err);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// resolve with all callback results if manyArgs is specified</span>
                    <span class="hljs-title function_">resolve</span>(manyArgs ? results : results[<span class="hljs-number">0</span>]); 
                }
            }

            args.<span class="hljs-title function_">push</span>(callback);

            f.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
        });
    };
}

<span class="hljs-comment">// usage</span>
f = <span class="hljs-title function_">promisify</span>(f, <span class="hljs-literal">true</span>);
<span class="hljs-title function_">f</span>(...).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">arrayOfResults</span> =></span> ..., <span class="hljs-function"><span class="hljs-params">err</span> =></span> ...);
</code></pre><blockquote><p>There are also modules with a bit more flexible promisification functions, e.g. <a href="https://github.com/digitaldesignlabs/es6-promisify">es6.promisify</a>. In Node.js, there's a built-in <code>util.promisify</code> function for that.</p></blockquote></details><br><h3 id="microtasks">Microtasks</h3><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();

promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">"promise done!"</span>));

<span class="hljs-title function_">alert</span>(<span class="hljs-string">"code finished"</span>); <span class="hljs-comment">// this alert shows first</span>
</code></pre><details><h4 id="microtasks-queue">Microtasks queue</h4><p>As stated in the <a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">specification</a>:</p><ul><li>The queue is first-in-first-out: tasks enqueued first are run first.</li><li>Execution of a task is initiated only when nothing else is running.</li></ul><p>When a promise is ready, its <code>.then/catch/finally</code> handlers are put into the queue, they are not executed yet. When the JavaScript engine becomes free from the current code, it takes a task from the queue and executes it.</p></details><br><h3 id="asyncawait">Async/await</h3><p>There's a special syntax to work with promises in a more comfortable fashion, called "async/await". It's surprisingly easy to understand and use.</p><details><h4 id="async-function">Async function</h4><p>The word <code>async</code> before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-title function_">f</span>().<span class="hljs-title function_">then</span>(alert); <span class="hljs-comment">// 1</span>
</code></pre><p>...We could explicity return a promise, which would be the same:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-title function_">f</span>().<span class="hljs-title function_">then</span>(alert); <span class="hljs-comment">// 1</span>
</code></pre><h4 id="await">Await</h4><p>The keyword <code>await</code> makes JavaScript wait until the promise settles and returns it result</p><blockquote><p>It works only inside async functions.</p></blockquote><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> promise;
</code></pre><p>Here's an example with a promise that resolves in 1 second:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"done!"</span>), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> promise; <span class="hljs-comment">// wait until the promise resolves</span>
    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// "done!"</span>
}
</code></pre><h4 id="error-handling-1">Error handling</h4><p>If a promise resolves normally, then <code>await promise</code> returns the result. But in the case of a rejection, it throws the error, just as if there were a <code>throw</code> statement at that line.</p><pre><code class="hljs language-js"><span class="hljs-comment">// This code</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>));
}

<span class="hljs-comment">// ...is the same as this</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Whoops!"</span>);
}
</code></pre><p>We can catch errors using <code>try...catch</code>, the same way as a regular <code>throw</code>:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://no-such-url'</span>);
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-title function_">alert</span>(err); <span class="hljs-comment">// TypeError: failed to fetch</span>
    }
}

<span class="hljs-title function_">f</span>()
</code></pre><p>In the case of an error, the control jumps to the <code>catch</code> block. We can also wrap multiple lines:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/no-user-here'</span>);
        <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-comment">// catches errors both in fetch and response.json</span>
        <span class="hljs-title function_">alert</span>(err);
    }
}

<span class="hljs-title function_">f</span>();
</code></pre><p>If we don't have <code>try...catch</code>, then the promise generated by the call of the async function <code>f()</code> becomes rejected. We can append <code>.catch</code> to handle it:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://no-such-url'</span>);
}

<span class="hljs-comment">// f() becomes a rejected promise</span>
<span class="hljs-title function_">f</span>().<span class="hljs-title function_">catch</span>(alert); <span class="hljs-comment">// TypeError: failed to fetch</span>
</code></pre></details><br><br><br><h2 id="generators-advanced-iteration">Generators, advanced iteration</h2><h3 id="generators">Generators</h3><p>Regular functions return only one, single value (or nothing).</p><p>Generators can return ("yield") multiple values, one after another, on-demand. They work great with <a href="#iterables">iterables</a>, allowing to create data streams with ease.</p><details><h4 id="generator-functions">Generator functions</h4><p>To create a generator, we need a special syntax construct: <code>function*</code>, so-called "generator function".</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}

<span class="hljs-comment">// "generator function" creates "generator object"</span>
<span class="hljs-keyword">let</span> generator = <span class="hljs-title function_">generateSequence</span>();
<span class="hljs-title function_">alert</span>(generator); <span class="hljs-comment">// [object Generator]</span>

<span class="hljs-keyword">let</span> one = generator.<span class="hljs-title function_">next</span>();
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(one)); <span class="hljs-comment">// {value: 1, done: false}</span>

<span class="hljs-keyword">let</span> two = generator.<span class="hljs-title function_">next</span>();
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(two)); <span class="hljs-comment">// {value: 2, done: false}</span>

<span class="hljs-keyword">let</span> three = generator.<span class="hljs-title function_">next</span>();
<span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(three)); <span class="hljs-comment">// {value: 3, done: true}</span>
</code></pre><h4 id="generators-are-iterable">Generators are iterable</h4><pre><code class="hljs language-js"><span class="hljs-comment">// We can loop over their values using `for...of`</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> generator) {
    <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1, then 2 but doesn't show 3</span>
                  <span class="hljs-comment">// for...of ignores the last value when done: true</span>
}

<span class="hljs-comment">// We can call all related functionality, e.g the spread syntax ...</span>
<span class="hljs-keyword">let</span> sequence = [<span class="hljs-number">0</span>, ...<span class="hljs-title function_">generateSequence</span>()];
<span class="hljs-title function_">alert</span>(sequence) <span class="hljs-comment">// 0, 1, 2, 3</span>
</code></pre><h4 id="generator-composition">Generator composition</h4><p>Generator composition is a special feature of generators that allows to transparently "embed" generators in each other.</p><p>For instance, we have a function that generates a sequence of numbers:</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-params">start, end</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) <span class="hljs-keyword">yield</span> i;
}
</code></pre><p>Now we'd like to reuse it to generate a more complex sequence:</p><ul><li>First, digits <code>0...9</code> (with charactar codes 48...57)</li><li>Followed by uppercase alphabet letters <code>A...Z</code> (character codes 65...90)</li><li>Followed by lowercase alphabet letters <code>a...z</code> (character codes 97...122)</li></ul><p>For generators, there's a special <code>yield*</code> syntax to "embed" (compose) one generator into another.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatePasswordCodes</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 0...9</span>
    <span class="hljs-comment">// Same as `for(let i = start; i &lt;= end; i++) yield i;`</span>
    <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-number">48</span>, <span class="hljs-number">57</span>);
    <span class="hljs-comment">// A...Z</span>
    <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-number">65</span>, <span class="hljs-number">90</span>);
    <span class="hljs-comment">// a...z</span>
    <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-number">97</span>, <span class="hljs-number">122</span>);
}

<span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> code <span class="hljs-keyword">of</span> <span class="hljs-title function_">generatePasswordCodes</span>()) {
    str += <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(code);
}

<span class="hljs-title function_">alert</span>(str); <span class="hljs-comment">// 0...9A...Za...z</span>
</code></pre><h4 id="yield-is-a-two-way-street">"yield" is a two-way street</h4><p><code>yield</code> are much more powerful and flexible. It not only returns the result to the outside, but also can pass the value inside the generator.</p><p>To do so, we should call <code>generator.next(arg)</code>, with an argument. That argument becomes the result of <code>yield</code>.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> ask1 = <span class="hljs-keyword">yield</span> <span class="hljs-string">"2 + 2 = ?"</span>;

    <span class="hljs-title function_">alert</span>(ask1); <span class="hljs-comment">// 4</span>

    <span class="hljs-keyword">let</span> ask2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">"3 * 3 = ?"</span>;

    <span class="hljs-title function_">alert</span>(ask2); <span class="hljs-comment">// 9</span>
}

<span class="hljs-keyword">let</span> generator = <span class="hljs-title function_">gen</span>();

<span class="hljs-title function_">alert</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// "2 + 2 = ?"</span>
<span class="hljs-title function_">alert</span>(generator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// "3 + 3 = ?"</span>
<span class="hljs-title function_">alert</span>(generator.<span class="hljs-title function_">next</span>(<span class="hljs-number">9</span>).<span class="hljs-property">done</span>); <span class="hljs-comment">// true</span>
</code></pre><h4 id="generatorthrow">Generator.throw</h4><p>To pass an error into a <code>yield</code>, we should call <code>generator.throw(err)</code>. In that case, the <code>err</code> is thrown in the line with that <code>yield</code>.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-string">"2 + 2 = ?"</span>;
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">"The execution does not reach here, because the exception is thrown above"</span>);
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-title function_">alert</span>(e); <span class="hljs-comment">// shows the error</span>
    }
}

<span class="hljs-keyword">let</span> generator = <span class="hljs-title function_">gen</span>();
<span class="hljs-keyword">let</span> question = generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;
generator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"The answer is not found in my database"</span>));
</code></pre><h4 id="generatorreturn">Generator.return</h4><p><code>generator.return(value)</code> finishes the generator execution and return the given <code>value</code>.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">const</span> g = <span class="hljs-title function_">gen</span>();
g.<span class="hljs-title function_">next</span>();        <span class="hljs-comment">// {value: 1, done: false}</span>
g.<span class="hljs-keyword">return</span>(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// {value: "foo", done: true}</span>
g.<span class="hljs-title function_">next</span>();        <span class="hljs-comment">// {value: undefined, done: true}</span>
</code></pre></details><br><h3 id="async-iteration-and-generators">Async iteration and generators</h3><p>Asynchronous iteration allow us to iterate over data that comes asynchrorously, on-demand. Like, for instance, when we download something chunk-by-chunk over a network.</p><details><h4 id="recall-iterables">Recall iterables</h4><p>Let's recall the topic about <a href="#iterables">iterables</a>.</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> range = {
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() { <span class="hljs-comment">// called once, in the beginning of for...of</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">current</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>,
            <span class="hljs-attr">last</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,

            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">// called every iteration, to get the next value</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) {
                    <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++};
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>};
                }
            }
        };
    }
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> range) {
    <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1 then 2, then 3, then 4, then 5</span>
}
</code></pre><h4 id="async-iterables">Async iterables</h4><p>Asynchronous iteration is needed when values come asynchronously: after <code>setTimeout</code> or another kind of delay.</p><p>To make an object iterable asynchronously:</p><ol><li><p>Use <code>Symbol.asyncIterator</code> instead of <code>Symbol.iterator</code>.</p></li><li><p>The <code>next()</code> method should return a promise (to be fulfilled with the next value).</p><ul><li>The <code>async</code> keyword handles it, we can simply make <code>async next()</code>.</li></ul></li><li><p>To iterate over such an object, we should use a <code>for await (let item of iterable)</code> loop.</p><ul><li>Note the <code>await</code> word.</li></ul></li></ol><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> range = {
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">current</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>,
            <span class="hljs-attr">last</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,

            <span class="hljs-keyword">async</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
                <span class="hljs-comment">// not : we can use "await" inside the async next:</span>
                <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));

                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) {
                    <span class="hljs-keyword">return</span> {doneL <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++};
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>};
                }
            }
        };
    }
};

(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> range) {
        <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1,2,3,4,5</span>
    }
})()
</code></pre><br><p>Table with the differences between <strong>Iterators</strong> and <strong>Async iterators</strong>:</p><table><thead><tr><th></th><th>Iterators</th><th>Async iterators</th></tr></thead><tbody><tr><td>Object method to provide iterator</td><td><code>Symbol.iterator</code></td><td><code>Symbol.asyncIterator</code></td></tr><tr><td><code>next()</code> return value is</td><td>any value</td><td><code>Promise</code></td></tr><tr><td>to loop, use</td><td><code>for...of</code></td><td><code>for await...of</code></td></tr></tbody></table><h4 id="recall-generators">Recall generators</h4><p>Let's recall the topic about <a href="#generators">generators</a>. Generators are labelled with <code>function*</code> (not the start) and use <code>yield</code> to generate a value, then we can use <code>for...of</code> to loop over them.</p><pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-params">start, end</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start, i &lt;= end; i++) <span class="hljs-keyword">yield</span> i;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> <span class="hljs-title function_">generateSequence</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) {
    <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1, then 2, then 3, then 4, then 5</span>
}
</code></pre><p>A common practice for <code>Symbol...iterator</code> is to return a generator:</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> range = {
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() { <span class="hljs-comment">// a shorthand for [Symbol.iterator]: function*()</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">form</span>; value &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>; value++) {
            <span class="hljs-keyword">yield</span> value;
        }
    }
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> ragne) {
    <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1, then 2, then 3, then 4, then 5</span>
}
</code></pre><blockquote><p>In regular generators we can't use <code>await</code>. All values must come synchronously, as required by the <code>for...of</code> construct.</p></blockquote><h4 id="async-generators">Async generators</h4><p>The syntax is to prepend <code>function*</code> with <code>async</code>. That makes the generator asynchronous. And then use <code>for await (...)</code> to iterate over it:</p><pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-params">start, end</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) {
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
        <span class="hljs-keyword">yield</span> i;
    }
}

(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">let</span> generator = <span class="hljs-title function_">generateSequence</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> generator) {
        <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1, then 2, then 3, then 4, then 5 (with delay between)</span>
    }
})();
</code></pre><p><em>Async iterable range</em></p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> range = {
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

    <span class="hljs-comment">// this line is same as [Symbol.asyncIterator]: async function*() </span>
    <span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>, value &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>; value++) {
            <span class="hljs-comment">// make a pause between values, wait for something</span>
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
            <span class="hljs-keyword">yield</span> value;
        }
    }
};

(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> range) {
        <span class="hljs-title function_">alert</span>(value); <span class="hljs-comment">// 1, then 2, then 3, then 4, then 5</span>
    }
})():
</code></pre></details><br><br><br><h2 id="modules">Modules</h2><h3 id="modules-introduction">Modules, introduction</h3><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { sayHi } <span class="hljs-keyword">from</span> <span class="hljs-string">"./sayHi.js"</span>;
</code></pre><details><p>Core module features:</p><ul><li>Always "use strict"</li><li>Module level scope</li></ul><pre><code class="hljs language-html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"hello.js"</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><ul><li>A module code is evaluated only the first time when imported</li></ul><pre><code class="hljs language-js"><span class="hljs-comment">// 📁 alert.js</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-string">"Module is evaluated!"</span>);
</code></pre><pre><code class="hljs language-js"><span class="hljs-comment">// Import the same module from different files</span>
<span class="hljs-comment">// 📁 1.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./alert.js'</span>; <span class="hljs-comment">// Module is evaluated!</span>

<span class="hljs-comment">// 📁 2.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./alert.js'</span>; <span class="hljs-comment">// (shows nothing)</span>
</code></pre><ul><li>import.media<br>The object <code>import.media</code> contains the information about the current module.</li></ul><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
    <span class="hljs-title function_">alert</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>); <span class="hljs-comment">// script URL</span>
    <span class="hljs-comment">// for an inline script - the URL of the current HTML-page</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre><ul><li>In a module, "this" is undefined</li></ul><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// window</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// undefined</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
</code></pre></details><br><h3 id="dynamic-imports">Dynamic imports</h3><p>First, we can't dynamically generate any parameters of <code>import</code>. The module path must be a primitive string, can't be a function call. This won't work:</p><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> ... <span class="hljs-keyword">from</span> <span class="hljs-title function_">getModuleName</span>(); <span class="hljs-comment">// Error, only from "string" is allowed</span>
</code></pre><p>Second, we can't import conditionally or at run-time:</p><pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (...) {
    <span class="hljs-keyword">import</span> ...; <span class="hljs-comment">// Error, not allowed!</span>
}

{
    <span class="hljs-keyword">import</span> ...; <span class="hljs-comment">// Error, we can't put import in any block</span>
}
</code></pre><p>But how can we import a module dynamically, on-demand?</p><details><h4 id="the-import-expression">The import() expression</h4><p>The <code>import(module)</code> expression loads the module and returns a promise that resolves into a module object that contains all its exports. It can be called from any place in the code.</p><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> modulePath = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">"Which module to load?"</span>);

<span class="hljs-keyword">import</span>(modulePath)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">obj</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj));
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"loading error, e.g. if no such module"</span>));

<span class="hljs-comment">// We could import like this if inside any async function</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(modulePath);
</code></pre></details><br><br><br><hr><h2 id="references">References</h2><ul><li><a href="https://javascript.info/">Javascript.info</a> - Part 1: The JavaScript language</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN Web Docs - Mozilla</a> - JavaScript</li></ul><p><br><br></p><hr><h2 id="upcoming">Upcoming</h2><p><em>Uncommon JavaScript Notes - Browser: Document, Events, Interfaces</em> - based on javascript.info's <a href="https://javascript.info/#tab-2">part 2</a>.</p><p><br><br></p></article><div class="page-copyright pb-3"><div><a href="https://github.com/khoaxuantu/tuslipid" rel="noreferrer" target="_blank" aria-label="web source code"><svg color="black" fill="currentColor" height="1em" opacity="0.8" stroke="currentColor" stroke-width="0" style="color:#000" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a></div>Built and designed by Xuan Khoa Tu Nguyen with <a href="https://react.dev/" rel="noreferrer" target="_blank">React</a>, <a href="https://www.typescriptlang.org/" rel="noreferrer" target="_blank">TypeScript</a> and <a href="https://sass-lang.com/" rel="noreferrer" target="_blank">Sass</a>.<br>Copyright © 2023 All Rights Reserved.</div></div></div></body></html>